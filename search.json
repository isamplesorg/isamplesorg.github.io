[
  {
    "objectID": "design/requirements.html",
    "href": "design/requirements.html",
    "title": "Requirements",
    "section": "",
    "text": "Mint identifiers and manage record.\nRecords are never deleted in SESAR. Sometimes they are deactivated.\nMetadata will need to be updated.\nDerived from\nActors\n\nCurator\nResearch Contributor\n\nComponents\n\niSB\nOriginal Source",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#mint-identifiers",
    "href": "design/requirements.html#mint-identifiers",
    "title": "Requirements",
    "section": "",
    "text": "Mint identifiers and manage record.\nRecords are never deleted in SESAR. Sometimes they are deactivated.\nMetadata will need to be updated.\nDerived from\nActors\n\nCurator\nResearch Contributor\n\nComponents\n\niSB\nOriginal Source",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#awareness-of-how-specimens-are-being-used",
    "href": "design/requirements.html#awareness-of-how-specimens-are-being-used",
    "title": "Requirements",
    "section": "02 Awareness of how specimens are being used",
    "text": "02 Awareness of how specimens are being used\nProvide metrics that indicate usage of a specimen.\nRequires that specimen access events are logged and retrievable.\nUsage metrics should include derived products as well, and so it is necessary to locate related content and usage metrics associated with the related content.\nDerived from:\n\nS1\n\nActors\n\nPortal manager\nResearch-contributor\nResearch-consumer\n\nComponents\n\niSB\niSC",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#availability-of-all-information-related-to-a-sample",
    "href": "design/requirements.html#availability-of-all-information-related-to-a-sample",
    "title": "Requirements",
    "section": "03 Availability of all information related to a sample",
    "text": "03 Availability of all information related to a sample\nA sample has related content. All relations (transitive) need to be discoverable in the view of a sample. There are different types of relations. For example an image may be associated with a sample through a relationship that is different to the relationship between a sample and derived products. In an RDF view, the type of relation is the predicate of the association between a sample (subject) and the related item (object). Relationships occur within a context and there may be multiple contexts associated with any content.\nDerived from:\n\nS2, S3, S4, S5, S10, O2, O8, O9, O10, O18, O11, O13, R02, R12, R17, G1, G3, G7, G9, G10, C1\n\nActors\n\nResearch-consumer\n\nComponents\n\niSC\niSB\nMetadata model",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#define-relationships-between-things-such-as-samples-and-derived-products",
    "href": "design/requirements.html#define-relationships-between-things-such-as-samples-and-derived-products",
    "title": "Requirements",
    "section": "04 Define relationships between things such as samples and derived products",
    "text": "04 Define relationships between things such as samples and derived products\nGuidelines and mechanisms to support the creation of relationships between things such as samples, images of samples, components of other projects (e.g. Field Notes project of Smithsonian), derived products, annotations.\nInstrument calibration records associated with an analysis.\nQ. Should relationships include actions like loaning a sample? This seems more like a provenance topic, though provenance can be expressed as relations…\nDerived from:\n\nS4, S3, S2, S6, O4, O8, O9, O18, O11, O12, O13, R17, G1, G3, G6, G7, C2\n\nActors\n\nResearch-contributor\nPortal manager\nCurator\n\nComponents\n\nMetadata model\niSC\niSB\nPortal",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#support-sample-management-loans-duplicates-subsamples",
    "href": "design/requirements.html#support-sample-management-loans-duplicates-subsamples",
    "title": "Requirements",
    "section": "05 Support sample management (loans, duplicates, subsamples)",
    "text": "05 Support sample management (loans, duplicates, subsamples)\nGuidelines and mechanisms to support tracking of samples on loan or moved to a new institution. Allow for duplicate samples in different organizations, as is common in botany. For samples that can be sub-samples, track the subsamples and the status (i.e. amount remaining) of the parent sample.\nNote that the process of sample loaning, moving, or other disposition is an operation of the collection. iSamples should support the tracking and discovery of samples that may be on loan or moved.\nDerived from:\n\nS1, S2, S6.2, S6.3, O2, O8, O9, G1,\n\nActors\n\nResearch-contributor\nPortal manager\nCurator\n\nComponents\n\nMetadata model\niSC\niSB\nPortal",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#all-metadata-for-all-samples-should-be-searchable-and-retrievable",
    "href": "design/requirements.html#all-metadata-for-all-samples-should-be-searchable-and-retrievable",
    "title": "Requirements",
    "section": "06 All metadata for all samples should be searchable and retrievable",
    "text": "06 All metadata for all samples should be searchable and retrievable\nSearchable should be against metadata properties. Can also be against relationship types. It may be feasible to search properties of related content up to n steps removed (n=0..?)\nSee also: Availability of all information related to a sample\nDerived from:\n\nS7, S6, S10, O2, O9, O10, O11, R02, R06, R12, G7, G10\n\nActors\n\nResearch-consumer\nResearch-contributor\nPortal manager\n\nComponents\n\nMetadata model\niSC (collated metadata)\niSB (expose metadata, retrieve subsets)",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#services-support-content-negotiation-alternate-renderings",
    "href": "design/requirements.html#services-support-content-negotiation-alternate-renderings",
    "title": "Requirements",
    "section": "07 Services support content negotiation, alternate renderings",
    "text": "07 Services support content negotiation, alternate renderings\nDifferent renderings of the same content are needed for different purposes. A human should see a different rendering of metadata than a piece of software. Note that the rendering may be performed client side using a programmatic expression of the metadata. For example, a web UI may consume the same JSON to render in HTML that is also used by software.\nDerived from:\n\nS9, O5, O6, R04, R05, R12, G9, G11\n\nActors\n\nAny user\n\nComponents\n\nAny component exposing content",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#recognize-that-any-entity-may-have-multiple-identifiers-some-of-which-may-not-be-globally-unique.",
    "href": "design/requirements.html#recognize-that-any-entity-may-have-multiple-identifiers-some-of-which-may-not-be-globally-unique.",
    "title": "Requirements",
    "section": "08 Recognize that any entity may have multiple identifiers, some of which may not be globally unique.",
    "text": "08 Recognize that any entity may have multiple identifiers, some of which may not be globally unique.\nThere are many examples of different types of identifiers attached to content. Some identifiers may be well formed (globally unique and resolvable) others may be more context specific. Context specific identifiers should include sufficient information to determine the context.\nAd-hoc identifiers created in the field can be an example of context specific identifiers. For example, a field investigator may simply label items 1, 2, 3, … Those identifiers are only useful when the context of their creation is known and available.\nGlobally unique identifiers may take many different forms (e.g. DOI, ARK, IGSN, …), there may be multiple GUIDs for content.\nIdentifiers may be used at different levels of aggregation.\nInappropriate use of identifiers (e.g. ROR for samples) should be discouraged or blocked.\nDerived from:\n\nO3, O4, O7, O12, O13, O15, O17, G2, G4, G5, G9, C1\n\nActors\n\nCurator\nResearch-contributor\nResearch-consumer\n\nComponents\n\nMetadata model\niSC\niSB",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#content-must-be-programmatically-accessible-and-transferable-to-different-systems",
    "href": "design/requirements.html#content-must-be-programmatically-accessible-and-transferable-to-different-systems",
    "title": "Requirements",
    "section": "09 Content must be programmatically accessible and transferable to different systems",
    "text": "09 Content must be programmatically accessible and transferable to different systems\nAll content should be accessible through API and should exhibit no loss of information in the transfer to another system.\nNote that it is expected that collections of content will be large (&gt;&gt; 10E6 items) so efficient paging, windowing and other subset selection mechanisms are needed.\nThe web publishing pattern (i.e. robots.txt -&gt; sitemap -&gt; schema.org) should be available for all resources appropriate for broad discovery.\nSee also Services support content negotiation, alternate renderings\nDerived from:\n\nO6, R04, R05, R06, R08, R10, R12, R17, G1, G9, G11\n\nActors\n\nResearch-consumer\n\nComponents\n\nAny components exposing APIs",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#user-interfaces-for-discovery-and-display-of-information-should-be-efficient-and-practical-for-research-use-and-expose-relationships-between-items-as-appropriate.",
    "href": "design/requirements.html#user-interfaces-for-discovery-and-display-of-information-should-be-efficient-and-practical-for-research-use-and-expose-relationships-between-items-as-appropriate.",
    "title": "Requirements",
    "section": "10 User Interfaces for discovery and display of information should be efficient and practical for research use and expose relationships between items as appropriate.",
    "text": "10 User Interfaces for discovery and display of information should be efficient and practical for research use and expose relationships between items as appropriate.\nAt the global scale, low resolution maps, timescales and general discovery mechanisms are useful. As specificity increases, opportunities for expressing relationships between content as a means of assisting discovery and interpretation can follow.\nSee also: \n\nAvailability of all information related to a sample\nAll metadata for all samples should be searchable and retrievable\n\nDerived from:\n\nO14, R01, R06, R08, G5. G6\n\nActors\n\nResearch-consumer\nCurator\n\nComponents\n\niSC\niSB",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#the-diversity-of-metadata-standards-in-use-should-be-supported-whilst-also-encouraging-consistency-in-use-and-possibly-reducing-the-diversity-as-appropriate-with-no-loss-of-meaning.",
    "href": "design/requirements.html#the-diversity-of-metadata-standards-in-use-should-be-supported-whilst-also-encouraging-consistency-in-use-and-possibly-reducing-the-diversity-as-appropriate-with-no-loss-of-meaning.",
    "title": "Requirements",
    "section": "11 The diversity of metadata standards in use should be supported whilst also encouraging consistency in use and possibly reducing the diversity as appropriate with no loss of meaning.",
    "text": "11 The diversity of metadata standards in use should be supported whilst also encouraging consistency in use and possibly reducing the diversity as appropriate with no loss of meaning.\nThere are many metadata formats in use, and this will continue. Creation of new metadata formats should be discouraged by facilitating concept matching to existing metadata elements. \nMixed authority metadata formats should be supported. E.g. a metadata document may contain concepts defined in Dublin Core, ISO-19115, and the Observation Data Model\nVocabulary reuse should be encouraged.\nStandard vocabularies for common concepts should be readily available (e.g. missing values, types of samples).\nRecognize that there are natural levels of aggregation for metadata describing different things. For example individuals, groups, organizations.\nDerived from:\n\nO16, R02, R03, R16, G4, G2, G5, G6, G10, G11\n\nActors\n\nResearch-contributor\nCurator\n\nComponents\n\niSB",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#ingest-and-deliver-metadata-in-multiple-open-formats",
    "href": "design/requirements.html#ingest-and-deliver-metadata-in-multiple-open-formats",
    "title": "Requirements",
    "section": "12 Ingest and deliver meta/data in multiple open formats",
    "text": "12 Ingest and deliver meta/data in multiple open formats\nPortals  may choose what formats they will allow for data upload and ingest and what format they want to use to deliver data. iSB shouldmust support the use of common open formats such as CSV, JSON, possibly XML and XLSX. \niSC will receive data only from iSB instances and project personnel, so it can limit the number of input formats. Metadata delivered as a result of searching the iSC index should be delivered in one or a few open formats.\nNote that translation between serialization formats may result in loss of information. Support of multiple serializations can significantly increase implementation overhead.\nDerived from:\nActors:\n\nResearch-contributor\n\nCurator\n\nComponents\n\niSB\niSC\nPortal",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#support-creation-of-identifiers-early-in-a-project",
    "href": "design/requirements.html#support-creation-of-identifiers-early-in-a-project",
    "title": "Requirements",
    "section": "13 Support creation of identifiers early in a project",
    "text": "13 Support creation of identifiers early in a project\nEarly association of an identifier with content improves efficiency of data handling. Ideally, identifiers should be reliably mintable with no knowledge except for an initial state.\nDerived from:\n\nC1\n\nActors:\n\nResearch-contributor\n\nCurator\n\nComponents\n\niSB",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#web-interfaces-should-be-flexible-and-loosely-coupled-through-standard-apis-to-encourage-diverse-adoption",
    "href": "design/requirements.html#web-interfaces-should-be-flexible-and-loosely-coupled-through-standard-apis-to-encourage-diverse-adoption",
    "title": "Requirements",
    "section": "14 Web interfaces should be flexible and loosely coupled through standard APIs to encourage diverse adoption",
    "text": "14 Web interfaces should be flexible and loosely coupled through standard APIs to encourage diverse adoption\nPortal web interfaces can serve a variety of audiences. In some cases (e.g. iSC) the interface will serve a very broad, diverse community. Other instances may be very specific (e.g. iSB or web UI serving the needs of a specific project). \nUIs should leverage standard APIs as far as possible, and underlying infrastructure should similarly express APIs using standard mechanisms.\nREST, GraphQL are common API standards that should be leveraged. Other more specific interfaces such as the various Open Geospatial Consortium standards, and HDF should be utilized in preference to custom APIs.\nDerived from:\n\nR05, R09, R08, R06, R10, R12\n\nActors\n\nResearch-contributor\n\nResearch-consumer\nCurator\n\nComponents\n\nAll",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#all-content-sources-should-be-assumed-to-be-dynamic-and-attached-components-should-facilitate-efficient-synchronization-of-subscribed-content.",
    "href": "design/requirements.html#all-content-sources-should-be-assumed-to-be-dynamic-and-attached-components-should-facilitate-efficient-synchronization-of-subscribed-content.",
    "title": "Requirements",
    "section": "15 All content sources should be assumed to be dynamic and attached components should facilitate efficient synchronization of subscribed content.",
    "text": "15 All content sources should be assumed to be dynamic and attached components should facilitate efficient synchronization of subscribed content.\nWith the transition to geoparquet-based data access, content synchronization now occurs through periodic updates of parquet files rather than real-time API synchronization. This approach provides better performance and reliability for analytical workloads.\nDerived from:\n\nR10, R12\n\nActors\n\nAdministrators\nResearch-consumer\nResearch-contributor\nCurator\n\nComponents\n\niSC\n\niSB\n\n## 16 Data and metadata to be stored by iSamples in a box.\nSESAR would like to utilize iSB as a data repository.\nAlso recognize that data and metadata may be stored on separate systems, and so reliable linking (e.g. via identifier) is necessary. Such indirect reference should be at least context aware (with context as part of metadata) or globally resolvable.\nNote: the data may be large and so all data may not be stored on iSC. Q. How to determine boundaries of what is replicated? Metadata will be copied to iSC.\nDerived from:\n\nR13, C2\n\nActors\n\nResearch-contributor\nCurator\n\nComponents\n\niSB",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#content-may-not-all-be-publicly-accessible.",
    "href": "design/requirements.html#content-may-not-all-be-publicly-accessible.",
    "title": "Requirements",
    "section": "17 Content may not all be publicly accessible.",
    "text": "17 Content may not all be publicly accessible.\nThere may be content (metadata, data, related content) with information that should not be publicly accessible (e.g. artifact location). This implies that the system should either reject access controlled content or implement access control at all levels.\nImplementation of access control all or nothing. It must be integrated at all levels and rigorous. A break in trust can have significant consequences beyond the project.\nLeverage existing user management infrastructure as far as possible. ORCID for user identification, oauth + JWT for access\nGroup management should be delegated to another system if possible. TODO: suggestions for infrastructure? Enable arbitrary group creation, management. Roles.\nDerived from:\n\nR14, O8, O9\n\nActors\n\nAll\n\nComponents\n\nAll",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/requirements.html#validation-rules-can-assist-with-production-of-higher-quality-content.",
    "href": "design/requirements.html#validation-rules-can-assist-with-production-of-higher-quality-content.",
    "title": "Requirements",
    "section": "18 Validation rules can assist with production of higher quality content. ",
    "text": "18 Validation rules can assist with production of higher quality content. \nJust like a spell checker, validation rules can assist with production of higher quality content. Validation rules should be sharable and reusable. Content entry / editing systems should leverage validation mechanisms for immediate user feedback and/or guidance.\nNote that validation is context dependent, and the validity rules may change over time.\nDerived from:\n\nG4, G8\n\nActors\n\nResearch-contributor\nCurator\n\nComponents\n\nPortal\niSB",
    "crumbs": [
      "Information Architecture",
      "Requirements"
    ]
  },
  {
    "objectID": "design/index.html",
    "href": "design/index.html",
    "title": "Overview",
    "section": "",
    "text": "Physical samples are represented by a digital record.\nEach digital record is addressable by at least one identifier that is unique to the record.\nA collection of digital records can be represented by a list of the record identifiers.\nA list of all physical sample digital record identifiers (global record list) can be constructed from the collection lists.\nDigital records may be presented in different serializations (media type).\nDigital records of a serialization may present different views of the same information (profile).\niSamples has defined a profile applicable to all physical samples.\niSamples has defined a programmatic interface\nPlantUML diagram removed for testing [SMR 2024-01-04]",
    "crumbs": [
      "Information Architecture",
      "Overview"
    ]
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html",
    "href": "LAZY_LOADING_IMPLEMENTATION.html",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Date: 2025-10-31 Purpose: Improve perceived performance of Cesium tutorial page\n\n\n\n\n\nProblem: Rendering thousands of geocode points in one blocking operation made the page unresponsive.\nSolution: Render points in batches of 500 with yields to browser event loop.\nconst CHUNK_SIZE = 500;\nfor (let i = 0; i &lt; data.length; i += CHUNK_SIZE) {\n    const chunk = data.slice(i, i + CHUNK_SIZE);\n    // ... add points for chunk\n\n    // Yield to browser between chunks\n    if (i + CHUNK_SIZE &lt; data.length) {\n        await new Promise(resolve =&gt; setTimeout(resolve, 0));\n    }\n}\nBenefits: - Page remains interactive during rendering - User sees progress (not just a frozen browser) - Can cancel/navigate away during load if needed\n\n\n\n\nProblem: User had no feedback during slow initial load.\nSolution: Update loading div with real-time progress.\nif (loadingDiv) {\n    const pct = Math.round((endIdx / data.length) * 100);\n    loadingDiv.innerHTML = `Rendering geocodes... ${endIdx.toLocaleString()}/${data.length.toLocaleString()} (${pct}%)`;\n}\nUser Experience: - “Querying geocodes from parquet…” (during SQL query) - “Rendering geocodes… 500/1,234 (41%)” (during rendering) - Progress hidden when complete\n\n\n\n\nProblem: No visibility into where time is spent.\nSolution: Use Performance API to measure each phase.\nMeasurements Added: 1. locations-query: Time to execute SQL query (lines 168-173) 2. locations-render: Time to render all points (lines 230-232) 3. locations-total: Total time from start to finish (lines 239-241)\nConsole Output:\nQuery executed in 2847ms - retrieved 1234 locations\nRendering completed in 412ms\nTotal time (query + render): 3259ms\n\n\n\n\nProblem: No visibility into per-query performance when user clicks geocode.\nSolution: Added timing to all three query functions.\nAdded to: - get_samples_1() - Path 1 (direct event location) - get_samples_2() - Path 2 (via site location) - get_samples_at_geo_cord_location_via_sample_event() - Eric’s query\nConsole Output:\nPath 1 query executed in 1523ms - retrieved 5 samples\nPath 2 query executed in 892ms - retrieved 0 samples\nEric's query executed in 1401ms - retrieved 5 samples\n\n\n\n\n\n\n\n\nInitial load: Page frozen for 5-10 seconds (no feedback)\nUser perception: “Is this working? Did it crash?”\nBrowser: Unresponsive during point rendering\n\n\n\n\n\nQuery phase: 2-8 seconds (depends on parquet download)\n\nUser sees: “Querying geocodes from parquet…”\n\nRendering phase: 400-800ms (chunked, with progress)\n\nUser sees: “Rendering geocodes… 500/1,234 (41%)”\n\nTotal perceived wait: Same absolute time, but feels 3-5x faster due to feedback\nBrowser: Remains responsive (can scroll, type, navigate)\n\n\n\n\n\nPath 1, Path 2, Eric’s queries: Still 1-2 seconds each (structural limitation)\nNow visible via console telemetry for optimization planning\n\n\n\n\n\n\n\n\nChrome/Edge: F12 or Cmd+Option+I (Mac) Firefox: F12 or Cmd+Option+K (Mac)\n\n\n\nNavigate to: http://localhost:5860/tutorials/parquet_cesium.html\n\n\n\nWatch for: - Loading indicator updates: “Querying geocodes…” → “Rendering… X/Y (Z%)” - Console logs with timing measurements - Page remains responsive (try scrolling, clicking buttons)\nExpected Console Output:\nQuery executed in 2847ms - retrieved 1234 locations\nRendering completed in 412ms\nTotal time (query + render): 3259ms\n\n\n\nSteps: 1. Click any geocode point on globe 2. Observe three query results tables render 3. Check console for query timings\nExpected Console Output:\nPath 1 query executed in 1523ms - retrieved 5 samples\nPath 2 query executed in 892ms - retrieved 0 samples\nEric's query executed in 1401ms - retrieved 5 samples\n\n\n\nUse search box: - Enter: geoloc_04d6e816218b1a8798fa90b3d1d43bf4c043a57f (PKAP with samples) - Click search - Verify camera flies to location - Verify all three tables render - Check console timings\n\n\n\n\n\nOnce you test locally, we can establish baseline metrics:\nInitial Load Metrics: - Query time: _____ ms - Render time: _____ ms - Total time: _____ ms - Number of geocodes: _____\nClick Query Metrics: - Path 1: _____ ms (_____ samples) - Path 2: _____ ms (_____ samples) - Eric’s query: _____ ms (_____ samples)\nThese baselines will help evaluate whether Phase 2 optimizations (pre-aggregated parquet) are worth pursuing.\n\n\n\n\n\n\n\nChunked rendering with progress\nPerformance telemetry\nDynamic loading indicators\n\n\n\n\nGoal: Reduce initial load from 3-8 seconds → &lt;1 second\nApproach: Pre-aggregate geocode classification query 1. Create oc_geocodes_classified.parquet (~50KB) via server-side script 2. Replace expensive CTE query with simple SELECT * FROM read_parquet(...) 3. Automate regeneration in GitHub Actions workflow\nWhen to pursue: - If query time consistently &gt;5 seconds - If users complain about initial load - If baseline data shows query is primary bottleneck\n\n\n\nGoal: Reduce click queries from 1-2 seconds → 200-400ms\nApproach: Denormalized edge indexes (see PERFORMANCE_OPTIMIZATION_PLAN.md)\nWhen to pursue: - Only if click query performance is unacceptable - After Phase 2 is complete - If baseline data shows queries are consistently &gt;2 seconds\n\n\n\n\n\n\n\n\nCheck: Is loading_1 div hidden by CSS?\nCheck: Browser console for JavaScript errors\nVerify: loadingDiv.hidden = false is executing (add console.log)\n\n\n\n\n\nVerify: Browser console is set to show “Verbose” or “All” messages\nCheck: Performance API available (typeof performance !== 'undefined')\nVerify: No JavaScript errors blocking execution\n\n\n\n\n\nReduce CHUNK_SIZE from 500 → 100 (more yields, slower but more responsive)\nCheck: Browser is not in “Performance” mode (some browsers batch setTimeout)\nVerify: await new Promise(...) is actually yielding (test with longer timeout)\n\n\n\n\n\n\nFile Modified: tutorials/parquet_cesium.qmd\nLines Changed: - 131-248: Enhanced locations query with telemetry + chunked rendering (+110 lines) - 400-406: Added telemetry to get_samples_1() (+6 lines) - 462-468: Added telemetry to get_samples_2() (+6 lines) - 524-530: Added telemetry to get_samples_at_geo_cord_location_via_sample_event() (+6 lines)\nTotal Impact: ~130 lines added (mostly comments + logging)\n\n\n\n\nBefore: 1. User loads page 2. [5-10 seconds of frozen browser with “Loading…” text] 3. Globe appears with all points 4. User clicks point 5. [1-2 seconds wait] 6. Tables appear\nAfter: 1. User loads page 2. Globe appears immediately 3. “Querying geocodes from parquet…” (2-8 sec) 4. “Rendering geocodes… 500/1,234 (41%)” (0.4-0.8 sec, visible progress) 5. All points visible, page interactive 6. User clicks point 7. [1-2 seconds wait] (console shows timing) 8. Tables appear\nKey Difference: User knows what’s happening and page remains responsive!\n\n\n\n\n\nNo data model changes: All optimizations are UX-level improvements\nNo breaking changes: Queries return same results, just with timing info\nNo maintenance burden: Once deployed, no ongoing work needed\nFully backwards compatible: Page works exactly the same, just feels faster\nConsole logs can be removed: If too noisy, delete console.log lines (keep timing code for future debugging)\n\n\n\n\n\nLazy Loading Implementation Complete When: - ✅ Progress indicator shows during initial load - ✅ Page remains interactive during rendering - ✅ Console logs show timing measurements - ✅ No JavaScript errors in console - ✅ All points render correctly (same as before) - ✅ Click queries work with timing logs\nReady for Next Phase When: - Baseline metrics collected (query times, render times) - User feedback gathered (is it fast enough?) - Decision made: Phase 2 optimization needed? (Y/N)"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#what-was-implemented",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#what-was-implemented",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Problem: Rendering thousands of geocode points in one blocking operation made the page unresponsive.\nSolution: Render points in batches of 500 with yields to browser event loop.\nconst CHUNK_SIZE = 500;\nfor (let i = 0; i &lt; data.length; i += CHUNK_SIZE) {\n    const chunk = data.slice(i, i + CHUNK_SIZE);\n    // ... add points for chunk\n\n    // Yield to browser between chunks\n    if (i + CHUNK_SIZE &lt; data.length) {\n        await new Promise(resolve =&gt; setTimeout(resolve, 0));\n    }\n}\nBenefits: - Page remains interactive during rendering - User sees progress (not just a frozen browser) - Can cancel/navigate away during load if needed\n\n\n\n\nProblem: User had no feedback during slow initial load.\nSolution: Update loading div with real-time progress.\nif (loadingDiv) {\n    const pct = Math.round((endIdx / data.length) * 100);\n    loadingDiv.innerHTML = `Rendering geocodes... ${endIdx.toLocaleString()}/${data.length.toLocaleString()} (${pct}%)`;\n}\nUser Experience: - “Querying geocodes from parquet…” (during SQL query) - “Rendering geocodes… 500/1,234 (41%)” (during rendering) - Progress hidden when complete\n\n\n\n\nProblem: No visibility into where time is spent.\nSolution: Use Performance API to measure each phase.\nMeasurements Added: 1. locations-query: Time to execute SQL query (lines 168-173) 2. locations-render: Time to render all points (lines 230-232) 3. locations-total: Total time from start to finish (lines 239-241)\nConsole Output:\nQuery executed in 2847ms - retrieved 1234 locations\nRendering completed in 412ms\nTotal time (query + render): 3259ms\n\n\n\n\nProblem: No visibility into per-query performance when user clicks geocode.\nSolution: Added timing to all three query functions.\nAdded to: - get_samples_1() - Path 1 (direct event location) - get_samples_2() - Path 2 (via site location) - get_samples_at_geo_cord_location_via_sample_event() - Eric’s query\nConsole Output:\nPath 1 query executed in 1523ms - retrieved 5 samples\nPath 2 query executed in 892ms - retrieved 0 samples\nEric's query executed in 1401ms - retrieved 5 samples"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#expected-performance-improvements",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#expected-performance-improvements",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Initial load: Page frozen for 5-10 seconds (no feedback)\nUser perception: “Is this working? Did it crash?”\nBrowser: Unresponsive during point rendering\n\n\n\n\n\nQuery phase: 2-8 seconds (depends on parquet download)\n\nUser sees: “Querying geocodes from parquet…”\n\nRendering phase: 400-800ms (chunked, with progress)\n\nUser sees: “Rendering geocodes… 500/1,234 (41%)”\n\nTotal perceived wait: Same absolute time, but feels 3-5x faster due to feedback\nBrowser: Remains responsive (can scroll, type, navigate)\n\n\n\n\n\nPath 1, Path 2, Eric’s queries: Still 1-2 seconds each (structural limitation)\nNow visible via console telemetry for optimization planning"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#testing-instructions",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#testing-instructions",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Chrome/Edge: F12 or Cmd+Option+I (Mac) Firefox: F12 or Cmd+Option+K (Mac)\n\n\n\nNavigate to: http://localhost:5860/tutorials/parquet_cesium.html\n\n\n\nWatch for: - Loading indicator updates: “Querying geocodes…” → “Rendering… X/Y (Z%)” - Console logs with timing measurements - Page remains responsive (try scrolling, clicking buttons)\nExpected Console Output:\nQuery executed in 2847ms - retrieved 1234 locations\nRendering completed in 412ms\nTotal time (query + render): 3259ms\n\n\n\nSteps: 1. Click any geocode point on globe 2. Observe three query results tables render 3. Check console for query timings\nExpected Console Output:\nPath 1 query executed in 1523ms - retrieved 5 samples\nPath 2 query executed in 892ms - retrieved 0 samples\nEric's query executed in 1401ms - retrieved 5 samples\n\n\n\nUse search box: - Enter: geoloc_04d6e816218b1a8798fa90b3d1d43bf4c043a57f (PKAP with samples) - Click search - Verify camera flies to location - Verify all three tables render - Check console timings"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#performance-baseline-data",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#performance-baseline-data",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Once you test locally, we can establish baseline metrics:\nInitial Load Metrics: - Query time: _____ ms - Render time: _____ ms - Total time: _____ ms - Number of geocodes: _____\nClick Query Metrics: - Path 1: _____ ms (_____ samples) - Path 2: _____ ms (_____ samples) - Eric’s query: _____ ms (_____ samples)\nThese baselines will help evaluate whether Phase 2 optimizations (pre-aggregated parquet) are worth pursuing."
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#next-steps-from-performance_optimization_plan.md",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#next-steps-from-performance_optimization_plan.md",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Chunked rendering with progress\nPerformance telemetry\nDynamic loading indicators\n\n\n\n\nGoal: Reduce initial load from 3-8 seconds → &lt;1 second\nApproach: Pre-aggregate geocode classification query 1. Create oc_geocodes_classified.parquet (~50KB) via server-side script 2. Replace expensive CTE query with simple SELECT * FROM read_parquet(...) 3. Automate regeneration in GitHub Actions workflow\nWhen to pursue: - If query time consistently &gt;5 seconds - If users complain about initial load - If baseline data shows query is primary bottleneck\n\n\n\nGoal: Reduce click queries from 1-2 seconds → 200-400ms\nApproach: Denormalized edge indexes (see PERFORMANCE_OPTIMIZATION_PLAN.md)\nWhen to pursue: - Only if click query performance is unacceptable - After Phase 2 is complete - If baseline data shows queries are consistently &gt;2 seconds"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#debugging-tips",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#debugging-tips",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Check: Is loading_1 div hidden by CSS?\nCheck: Browser console for JavaScript errors\nVerify: loadingDiv.hidden = false is executing (add console.log)\n\n\n\n\n\nVerify: Browser console is set to show “Verbose” or “All” messages\nCheck: Performance API available (typeof performance !== 'undefined')\nVerify: No JavaScript errors blocking execution\n\n\n\n\n\nReduce CHUNK_SIZE from 500 → 100 (more yields, slower but more responsive)\nCheck: Browser is not in “Performance” mode (some browsers batch setTimeout)\nVerify: await new Promise(...) is actually yielding (test with longer timeout)"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#code-changes-summary",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#code-changes-summary",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "File Modified: tutorials/parquet_cesium.qmd\nLines Changed: - 131-248: Enhanced locations query with telemetry + chunked rendering (+110 lines) - 400-406: Added telemetry to get_samples_1() (+6 lines) - 462-468: Added telemetry to get_samples_2() (+6 lines) - 524-530: Added telemetry to get_samples_at_geo_cord_location_via_sample_event() (+6 lines)\nTotal Impact: ~130 lines added (mostly comments + logging)"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#user-experience-flow",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#user-experience-flow",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Before: 1. User loads page 2. [5-10 seconds of frozen browser with “Loading…” text] 3. Globe appears with all points 4. User clicks point 5. [1-2 seconds wait] 6. Tables appear\nAfter: 1. User loads page 2. Globe appears immediately 3. “Querying geocodes from parquet…” (2-8 sec) 4. “Rendering geocodes… 500/1,234 (41%)” (0.4-0.8 sec, visible progress) 5. All points visible, page interactive 6. User clicks point 7. [1-2 seconds wait] (console shows timing) 8. Tables appear\nKey Difference: User knows what’s happening and page remains responsive!"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#additional-notes",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#additional-notes",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "No data model changes: All optimizations are UX-level improvements\nNo breaking changes: Queries return same results, just with timing info\nNo maintenance burden: Once deployed, no ongoing work needed\nFully backwards compatible: Page works exactly the same, just feels faster\nConsole logs can be removed: If too noisy, delete console.log lines (keep timing code for future debugging)"
  },
  {
    "objectID": "LAZY_LOADING_IMPLEMENTATION.html#success-criteria",
    "href": "LAZY_LOADING_IMPLEMENTATION.html#success-criteria",
    "title": "1 Lazy Loading Implementation",
    "section": "",
    "text": "Lazy Loading Implementation Complete When: - ✅ Progress indicator shows during initial load - ✅ Page remains interactive during rendering - ✅ Console logs show timing measurements - ✅ No JavaScript errors in console - ✅ All points render correctly (same as before) - ✅ Click queries work with timing logs\nReady for Next Phase When: - Baseline metrics collected (query times, render times) - User feedback gathered (is it fast enough?) - Decision made: Phase 2 optimization needed? (Y/N)"
  },
  {
    "objectID": "tutorials/zenodo_isamples_analysis.html",
    "href": "tutorials/zenodo_isamples_analysis.html",
    "title": "Efficient Analysis of Large iSamples Dataset from Zenodo",
    "section": "",
    "text": "This tutorial demonstrates how to efficiently analyze large geospatial datasets directly in your browser without downloading entire files. We’ll use DuckDB-WASM and Observable JS to perform fast, memory-efficient analysis and create interactive visualizations.\nNote: This tutorial attempts to connect to the live iSamples dataset (~300MB, 6+ million records). If CORS restrictions prevent access to the remote file, it automatically falls back to a representative demo dataset that demonstrates the same analytical techniques.\n\n\n\nDuckDB-WASM: In-browser analytical database with HTTP range request support\nObservable Plot: Grammar of graphics for interactive visualizations\nObservable Inputs: Interactive controls for data exploration\nCORS Handling: Automatic fallback for cross-origin restrictions\n\n\n\n\nPrimary dataset: - URL: https://labs.dataunbound.com/docs/2025/07/isamples_export_2025_04_21_16_23_46_geo.parquet (temporary for testing) - Original: https://zenodo.org/api/records/15278211/files/... (currently rate limited) - Size: ~300 MB, 6+ million records - Sources: SESAR, OpenContext, GEOME, Smithsonian\nNote: Currently using DataUnbound Labs hosting temporarily to avoid Zenodo rate limiting during development. This will be switched back to Zenodo once the notebook is stable.\nFallback dataset (if remote data fails): - Type: Generated demo data with realistic structure - Size: 10K records with same schema and representative geographic distribution - Purpose: Demonstrates all analytical techniques with faster loading",
    "crumbs": [
      "Getting Started",
      "Zenodo iSamples OpenContext Tutorial"
    ]
  },
  {
    "objectID": "tutorials/zenodo_isamples_analysis.html#key-technologies",
    "href": "tutorials/zenodo_isamples_analysis.html#key-technologies",
    "title": "Efficient Analysis of Large iSamples Dataset from Zenodo",
    "section": "",
    "text": "DuckDB-WASM: In-browser analytical database with HTTP range request support\nObservable Plot: Grammar of graphics for interactive visualizations\nObservable Inputs: Interactive controls for data exploration\nCORS Handling: Automatic fallback for cross-origin restrictions",
    "crumbs": [
      "Getting Started",
      "Zenodo iSamples OpenContext Tutorial"
    ]
  },
  {
    "objectID": "tutorials/zenodo_isamples_analysis.html#dataset-information",
    "href": "tutorials/zenodo_isamples_analysis.html#dataset-information",
    "title": "Efficient Analysis of Large iSamples Dataset from Zenodo",
    "section": "",
    "text": "Primary dataset: - URL: https://labs.dataunbound.com/docs/2025/07/isamples_export_2025_04_21_16_23_46_geo.parquet (temporary for testing) - Original: https://zenodo.org/api/records/15278211/files/... (currently rate limited) - Size: ~300 MB, 6+ million records - Sources: SESAR, OpenContext, GEOME, Smithsonian\nNote: Currently using DataUnbound Labs hosting temporarily to avoid Zenodo rate limiting during development. This will be switched back to Zenodo once the notebook is stable.\nFallback dataset (if remote data fails): - Type: Generated demo data with realistic structure - Size: 10K records with same schema and representative geographic distribution - Purpose: Demonstrates all analytical techniques with faster loading",
    "crumbs": [
      "Getting Started",
      "Zenodo iSamples OpenContext Tutorial"
    ]
  },
  {
    "objectID": "tutorials/parquet_isamples_opencontext.html",
    "href": "tutorials/parquet_isamples_opencontext.html",
    "title": "Parquet",
    "section": "",
    "text": "Let’s query Eric’s parquet file using duckdb+parquet\n\n\nCode\nparquet_path = 'https://storage.googleapis.com/opencontext-parquet/oc_isamples_pqg.parquet';\n\n// Create a DuckDB instance\ndb = {\n  const instance = await DuckDBClient.of();\n  await instance.query(`create view nodes as select * from read_parquet('${parquet_path}')`)\n  return instance;\n}\n\nrow_count = {\n  const result = await db.queryRow(`select count(*) as n from nodes;`);\n  return result.n;\n}\n\nresults = {\n  const data = await db.query(`SELECT COUNT(*) as count, otype FROM nodes GROUP BY otype ORDER BY count DESC`);\n  document.getElementById(\"loading_1\").hidden = true;\n  return Inputs.table(data);\n}\n\nrows1k = {\n  const data = await db.query(`SELECT row_id, pid, otype, label FROM nodes limit 1000`);\n  document.getElementById(\"loading_2\").hidden = true;\n  return Inputs.table(data);\n}\n\nmd`There are ${row_count} rows in the source &lt;code&gt;${parquet_path}&lt;/code&gt;.`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLoading type counts…\n\n\n\nThe first 1000 rows:\n\n\nLoading…"
  },
  {
    "objectID": "tutorials/parquet.html",
    "href": "tutorials/parquet.html",
    "title": "Parquet",
    "section": "",
    "text": "Let’s query Eric’s parquet file using duckdb+parquet\n\n\nCode\nparquet_path = 'https://storage.googleapis.com/opencontext-parquet/oc_isamples_pqg.parquet';\n\n// Create a DuckDB instance\ndb = {\n  const instance = await DuckDBClient.of();\n  await instance.query(`create view nodes as select * from read_parquet('${parquet_path}')`)\n  return instance;\n}\n\nrow_count = {\n  const result = await db.queryRow(`select count(*) as n from nodes;`);\n  return result.n;\n}\n\nresults = {\n  const data = await db.query(`SELECT COUNT(*) as count, otype FROM nodes GROUP BY otype ORDER BY count DESC`);\n  document.getElementById(\"loading_1\").hidden = true;\n  return Inputs.table(data);\n}\n\nrows1k = {\n  const data = await db.query(`SELECT row_id, pid, otype, label FROM nodes limit 1000`);\n  document.getElementById(\"loading_2\").hidden = true;\n  return Inputs.table(data);\n}\n\nmd`There are ${row_count} rows in the source &lt;code&gt;${parquet_path}&lt;/code&gt;.`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLoading type counts…\n\n\n\nThe first 1000 rows:\n\n\nLoading…",
    "crumbs": [
      "Getting Started",
      "iSamples Parquet Tutorial"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html",
    "href": "tutorials/narrow_vs_wide_performance.html",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "",
    "text": "This page benchmarks the performance difference between narrow and wide parquet schema formats when accessing data “over the wire” via HTTP range requests in DuckDB-WASM.",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#introduction",
    "href": "tutorials/narrow_vs_wide_performance.html#introduction",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "1 Introduction",
    "text": "1 Introduction\n\n1.1 What are Narrow vs Wide Schemas?\nThe iSamples property graph data can be serialized in two different parquet formats:\n\n\n\n\n\n\n\n\n\nFormat\nDescription\nFile Size\nRow Count\n\n\n\n\nNarrow\nStores relationships as separate edge rows (otype='_edge_')\n691 MB\n~11.6M rows\n\n\nWide\nStores relationships as p__* columns on entity rows\n275 MB\n~2.5M rows\n\n\n\nBoth formats represent the same underlying data with identical semantics, but the wide format is optimized for analytical queries by eliminating edge rows.\n\n\n1.2 Why Performance Matters\nWhen using DuckDB-WASM in the browser:\n\nData is fetched via HTTP range requests (206 Partial Content)\nOnly the columns and row groups needed for a query are downloaded\nSmaller files with fewer rows = fewer bytes to transfer, faster queries\n\nExpected speedup: Wide format should be 2-3x faster based on local benchmarks.",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#methodology",
    "href": "tutorials/narrow_vs_wide_performance.html#methodology",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "2 Methodology",
    "text": "2 Methodology\n\n\n\n\n\n\nNoteBenchmarking Approach\n\n\n\n\nCold run: First query (includes metadata fetch, JIT compilation) - reported separately\nWarm runs: Runs 2-3 (metadata cached, JIT warmed up)\nWarm median: Median of warm runs only (excludes cold run for fair comparison)\nSequential execution: Benchmarks run one after another, not concurrently\nNetwork variability: Results will vary based on your network connection and hardware\n\nResults are shown in real-time as benchmarks complete. Data loading only begins when you click the button.",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#setup",
    "href": "tutorials/narrow_vs_wide_performance.html#setup",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "3 Setup",
    "text": "3 Setup\n\n\nCode\n// Import DuckDB for browser-based SQL analysis (pinned version for reproducibility)\nimport { DuckDBClient } from \"https://cdn.jsdelivr.net/npm/@observablehq/duckdb@0.7.1/+esm\"\n\n\n\n\n\n\n\n\n\nCode\nnarrowUrl = \"https://storage.googleapis.com/opencontext-parquet/oc_isamples_pqg.parquet\"\nwideUrl = \"https://storage.googleapis.com/opencontext-parquet/oc_isamples_pqg_wide.parquet\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.1 Environment Info\n\n\nCode\nenvInfo = {\n    const ua = navigator.userAgent;\n    const browser = ua.includes('Chrome') ? 'Chrome' : ua.includes('Firefox') ? 'Firefox' : ua.includes('Safari') ? 'Safari' : 'Unknown';\n    const connection = navigator.connection || {};\n\n    return {\n        browser: browser,\n        userAgent: ua.substring(0, 80) + '...',\n        downlink: connection.downlink ? `${connection.downlink} Mbps` : 'N/A',\n        effectiveType: connection.effectiveType || 'N/A',\n        rtt: connection.rtt ? `${connection.rtt} ms` : 'N/A'\n    };\n}\n\nhtml`&lt;div style=\"background: #f5f5f5; padding: 10px; border-radius: 5px; font-size: 12px; font-family: monospace;\"&gt;\n&lt;strong&gt;Environment:&lt;/strong&gt;&lt;br&gt;\nBrowser: ${envInfo.browser}&lt;br&gt;\nConnection: ${envInfo.effectiveType} (${envInfo.downlink}, RTT: ${envInfo.rtt})&lt;br&gt;\n&lt;em&gt;Note: Results will vary by network/hardware&lt;/em&gt;\n&lt;/div&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2 Run Benchmarks\n\n\nCode\nviewof runBenchmarks = Inputs.button(\"Run All Benchmarks\", {\n    style: \"padding: 12px 24px; background: #2E86AB; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px;\"\n})\n\n\n\n\n\n\n\n\nInitializing… Loading databases and preparing benchmarks. This may take a moment as parquet metadata is fetched over HTTP.\n\n\n\n\n\n\nCode\ninitDatabases = {\n    if (runBenchmarks &lt; 1) return null;\n\n    const loadingDiv = document.getElementById('loading_init');\n    const errorDiv = document.getElementById('error_display');\n\n    if (loadingDiv) loadingDiv.style.display = 'block';\n    if (errorDiv) errorDiv.style.display = 'none';\n\n    try {\n        const narrowDb = await DuckDBClient.of();\n        await narrowDb.query(`CREATE VIEW narrow AS SELECT * FROM read_parquet('${narrowUrl}')`);\n\n        const wideDb = await DuckDBClient.of();\n        await wideDb.query(`CREATE VIEW wide AS SELECT * FROM read_parquet('${wideUrl}')`);\n\n        if (loadingDiv) loadingDiv.style.display = 'none';\n        return { narrow: narrowDb, wide: wideDb };\n    } catch (e) {\n        const errorMsg = `Failed to initialize databases: ${e.message}. This may be due to network issues or CORS restrictions.`;\n        if (errorDiv) {\n            errorDiv.textContent = errorMsg;\n            errorDiv.style.display = 'block';\n        }\n        if (loadingDiv) loadingDiv.style.display = 'none';\n        return { error: errorMsg };\n    }\n}\n\ndbNarrow = initDatabases && !initDatabases.error ? initDatabases.narrow : null\ndbWide = initDatabases && !initDatabases.error ? initDatabases.wide : null",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#data-validity-check",
    "href": "tutorials/narrow_vs_wide_performance.html#data-validity-check",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "4 Data Validity Check",
    "text": "4 Data Validity Check\nBefore benchmarking, let’s confirm both schemas represent the same underlying data.\n\nChecking data validity…\n\n\n\nCode\nvalidityCheck = {\n    // Only run when button clicked AND databases are initialized\n    if (runBenchmarks &lt; 1 || !dbNarrow || !dbWide) return null;\n\n    const loadingDiv = document.getElementById('loading_validity');\n    const errorDiv = document.getElementById('error_display');\n    if (loadingDiv) loadingDiv.hidden = false;\n\n    try {\n        // Count rows in narrow\n        const narrowCount = await dbNarrow.query(`SELECT COUNT(*) as cnt FROM narrow`);\n        const narrowTotal = narrowCount[0].cnt;\n\n        // Count rows in wide\n        const wideCount = await dbWide.query(`SELECT COUNT(*) as cnt FROM wide`);\n        const wideTotal = wideCount[0].cnt;\n\n        // Count entity types in narrow (excluding edges)\n        const narrowEntities = await dbNarrow.query(`\n            SELECT COUNT(*) as cnt FROM narrow\n            WHERE otype != '_edge_'\n        `);\n        const narrowEntityCount = narrowEntities[0].cnt;\n\n        // Count samples in both\n        const narrowSamples = await dbNarrow.query(`\n            SELECT COUNT(*) as cnt FROM narrow\n            WHERE otype = 'MaterialSampleRecord'\n        `);\n\n        const wideSamples = await dbWide.query(`\n            SELECT COUNT(*) as cnt FROM wide\n            WHERE otype = 'MaterialSampleRecord'\n        `);\n\n        return {\n            narrowTotal: narrowTotal,\n            wideTotal: wideTotal,\n            narrowEntities: narrowEntityCount,\n            narrowSamples: narrowSamples[0].cnt,\n            wideSamples: wideSamples[0].cnt,\n            sampleMatch: narrowSamples[0].cnt === wideSamples[0].cnt\n        };\n    } catch (e) {\n        if (errorDiv) {\n            errorDiv.textContent = `Validity check failed: ${e.message}`;\n            errorDiv.style.display = 'block';\n        }\n        return { error: e.message };\n    } finally {\n        if (loadingDiv) loadingDiv.hidden = true;\n    }\n}\n\n\n\n\n\n\n\n\n\nCode\nvalidityCheck ? (validityCheck.error ? html`\n&lt;div style=\"background: #f8d7da; padding: 15px; border-radius: 5px; margin: 10px 0;\"&gt;\n&lt;h4 style=\"margin-top: 0;\"&gt;Data Validity Results&lt;/h4&gt;\n&lt;p style=\"margin: 0;\"&gt;&lt;strong&gt;Validity check failed:&lt;/strong&gt; ${validityCheck.error}&lt;/p&gt;\n&lt;/div&gt;\n` : html`\n&lt;div style=\"background: ${validityCheck.sampleMatch ? '#d4edda' : '#f8d7da'}; padding: 15px; border-radius: 5px; margin: 10px 0;\"&gt;\n&lt;h4 style=\"margin-top: 0;\"&gt;Data Validity Results&lt;/h4&gt;\n&lt;table style=\"width: 100%; border-collapse: collapse;\"&gt;\n&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Narrow total rows:&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;${validityCheck.narrowTotal.toLocaleString()}&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Wide total rows:&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;${validityCheck.wideTotal.toLocaleString()}&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Narrow entities (non-edge):&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;${validityCheck.narrowEntities.toLocaleString()}&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Narrow samples:&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;${validityCheck.narrowSamples.toLocaleString()}&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Wide samples:&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;${validityCheck.wideSamples.toLocaleString()}&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Sample count match:&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;${validityCheck.sampleMatch ? '✅ Yes' : '❌ No'}&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;\n&lt;p&gt;&lt;em&gt;The wide schema has ~79% fewer rows because edge rows are eliminated and stored as columns.&lt;/em&gt;&lt;/p&gt;\n&lt;/div&gt;\n`) : html`&lt;p&gt;&lt;em&gt;Click \"Run All Benchmarks\" to check data validity&lt;/em&gt;&lt;/p&gt;`",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#benchmark-1-entity-count-query",
    "href": "tutorials/narrow_vs_wide_performance.html#benchmark-1-entity-count-query",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "5 Benchmark 1: Entity Count Query",
    "text": "5 Benchmark 1: Entity Count Query\nThis benchmark tests a simple COUNT(*) GROUP BY otype query, which requires scanning row metadata.\n\nRunning Benchmark 1…\n\n\n\nCode\nbenchmark1 = {\n    // Wait for validity check to complete first (sequential execution)\n    if (runBenchmarks &lt; 1 || !validityCheck || validityCheck.error) return null;\n\n    const loadingDiv = document.getElementById('loading_b1');\n    const errorDiv = document.getElementById('error_display');\n    if (loadingDiv) loadingDiv.hidden = false;\n\n    const query = `SELECT otype, COUNT(*) as cnt FROM {table} GROUP BY otype ORDER BY cnt DESC`;\n    const runs = 3;\n\n    try {\n        // Narrow benchmark\n        const narrowTimes = [];\n        for (let i = 0; i &lt; runs; i++) {\n            const start = performance.now();\n            await dbNarrow.query(query.replace('{table}', 'narrow'));\n            narrowTimes.push(performance.now() - start);\n        }\n\n        // Wide benchmark\n        const wideTimes = [];\n        for (let i = 0; i &lt; runs; i++) {\n            const start = performance.now();\n            await dbWide.query(query.replace('{table}', 'wide'));\n            wideTimes.push(performance.now() - start);\n        }\n\n        // Calculate medians (excluding cold run for warm median)\n        const median = arr =&gt; {\n            const sorted = [...arr].sort((a, b) =&gt; a - b);\n            if (sorted.length === 2) return (sorted[0] + sorted[1]) / 2;\n            return sorted[Math.floor(sorted.length / 2)];\n        };\n        const warmMedian = arr =&gt; {\n            if (arr.length &lt;= 1) return arr[0] || 0;\n            const warm = arr.slice(1); // exclude first (cold) run\n            return median(warm);\n        };\n\n        const narrowMedian = warmMedian(narrowTimes);\n        const wideMedian = warmMedian(wideTimes);\n\n        return {\n            name: \"Entity Count (GROUP BY otype)\",\n            narrowCold: narrowTimes[0],\n            narrowMedian: narrowMedian,\n            narrowAll: narrowTimes,\n            wideCold: wideTimes[0],\n            wideMedian: wideMedian,\n            wideAll: wideTimes,\n            speedup: narrowMedian / wideMedian\n        };\n    } catch (e) {\n        if (errorDiv) {\n            errorDiv.textContent = `Benchmark 1 failed: ${e.message}`;\n            errorDiv.style.display = 'block';\n        }\n        return { error: e.message };\n    } finally {\n        if (loadingDiv) loadingDiv.hidden = true;\n    }\n}\n\n\n\n\n\n\n\n\n\nCode\nbenchmark1 ? (benchmark1.error ? html`\n&lt;div style=\"background: #f8d7da; padding: 15px; border-radius: 5px; margin: 10px 0;\"&gt;\n&lt;h4 style=\"margin-top: 0;\"&gt;Benchmark 1 Error&lt;/h4&gt;\n&lt;p style=\"margin: 0;\"&gt;&lt;strong&gt;Benchmark 1 failed:&lt;/strong&gt; ${benchmark1.error}&lt;/p&gt;\n&lt;/div&gt;\n` : html`\n&lt;div style=\"background: #e7f3ff; padding: 15px; border-radius: 5px; margin: 10px 0;\"&gt;\n&lt;h4 style=\"margin-top: 0;\"&gt;${benchmark1.name}&lt;/h4&gt;\n&lt;table style=\"width: 100%; border-collapse: collapse; text-align: right;\"&gt;\n&lt;thead&gt;\n&lt;tr style=\"border-bottom: 2px solid #ccc;\"&gt;\n&lt;th style=\"text-align: left;\"&gt;Schema&lt;/th&gt;\n&lt;th&gt;Cold (1st run)&lt;/th&gt;\n&lt;th&gt;Warm (median)&lt;/th&gt;\n&lt;th&gt;All runs&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;&lt;td style=\"text-align: left;\"&gt;&lt;strong&gt;Narrow&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;${benchmark1.narrowCold.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark1.narrowMedian.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark1.narrowAll.map(t =&gt; t.toFixed(0)).join(', ')} ms&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td style=\"text-align: left;\"&gt;&lt;strong&gt;Wide&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;${benchmark1.wideCold.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark1.wideMedian.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark1.wideAll.map(t =&gt; t.toFixed(0)).join(', ')} ms&lt;/td&gt;&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p style=\"margin-bottom: 0;\"&gt;&lt;strong&gt;Speedup: ${benchmark1.speedup.toFixed(2)}x&lt;/strong&gt; (wide is ${benchmark1.speedup &gt; 1 ? 'faster' : 'slower'})&lt;/p&gt;\n&lt;/div&gt;\n`) : html`&lt;p&gt;&lt;em&gt;Waiting for benchmark...&lt;/em&gt;&lt;/p&gt;`",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#benchmark-2-sample-count-by-site",
    "href": "tutorials/narrow_vs_wide_performance.html#benchmark-2-sample-count-by-site",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "6 Benchmark 2: Sample Count by Site",
    "text": "6 Benchmark 2: Sample Count by Site\nThis benchmark counts samples per sampling site, requiring a join between samples and sites.\nQuery complexity: - Narrow: Requires joining through edge rows - Wide: Direct join via p__* columns\n\nRunning Benchmark 2…\n\n\n\nCode\nbenchmark2 = {\n    // Wait for benchmark1 to complete first (sequential execution)\n    if (runBenchmarks &lt; 1 || !benchmark1 || benchmark1.error) return null;\n\n    const loadingDiv = document.getElementById('loading_b2');\n    const errorDiv = document.getElementById('error_display');\n    if (loadingDiv) loadingDiv.hidden = false;\n\n    // Narrow query: traverse edges to get from sample -&gt; event -&gt; site\n    const narrowQuery = `\n        WITH sample_events AS (\n            SELECT\n                e.o[1] as event_id,\n                s.row_id as sample_id\n            FROM narrow s\n            JOIN narrow e ON s.row_id = e.s AND e.p = 'produced_by'\n            WHERE s.otype = 'MaterialSampleRecord'\n        ),\n        event_sites AS (\n            SELECT\n                se.sample_id,\n                e2.o[1] as site_id\n            FROM sample_events se\n            JOIN narrow e2 ON se.event_id = e2.s AND e2.p = 'sampling_site'\n        )\n        SELECT\n            site.label,\n            COUNT(*) as sample_count\n        FROM event_sites es\n        JOIN narrow site ON es.site_id = site.row_id\n        GROUP BY site.label\n        ORDER BY sample_count DESC\n        LIMIT 10\n    `;\n\n    // Wide query: direct column access\n    const wideQuery = `\n        WITH sample_sites AS (\n            SELECT\n                s.row_id as sample_id,\n                e.p__sampling_site[1] as site_id\n            FROM wide s\n            JOIN wide e ON s.p__produced_by[1] = e.row_id\n            WHERE s.otype = 'MaterialSampleRecord'\n              AND e.otype = 'SamplingEvent'\n        )\n        SELECT\n            site.label,\n            COUNT(*) as sample_count\n        FROM sample_sites ss\n        JOIN wide site ON ss.site_id = site.row_id\n        WHERE site.otype = 'SamplingSite'\n        GROUP BY site.label\n        ORDER BY sample_count DESC\n        LIMIT 10\n    `;\n\n    const runs = 3;\n\n    try {\n        // Narrow benchmark\n        const narrowTimes = [];\n        for (let i = 0; i &lt; runs; i++) {\n            const start = performance.now();\n            await dbNarrow.query(narrowQuery);\n            narrowTimes.push(performance.now() - start);\n        }\n\n        // Wide benchmark\n        const wideTimes = [];\n        for (let i = 0; i &lt; runs; i++) {\n            const start = performance.now();\n            await dbWide.query(wideQuery);\n            wideTimes.push(performance.now() - start);\n        }\n\n        const median = arr =&gt; {\n            const sorted = [...arr].sort((a, b) =&gt; a - b);\n            if (sorted.length === 2) return (sorted[0] + sorted[1]) / 2;\n            return sorted[Math.floor(sorted.length / 2)];\n        };\n        const warmMedian = arr =&gt; {\n            if (arr.length &lt;= 1) return arr[0] || 0;\n            const warm = arr.slice(1);\n            return median(warm);\n        };\n\n        const narrowMedian = warmMedian(narrowTimes);\n        const wideMedian = warmMedian(wideTimes);\n\n        return {\n            name: \"Sample Count by Site (multi-join)\",\n            narrowCold: narrowTimes[0],\n            narrowMedian: narrowMedian,\n            narrowAll: narrowTimes,\n            wideCold: wideTimes[0],\n            wideMedian: wideMedian,\n            wideAll: wideTimes,\n            speedup: narrowMedian / wideMedian\n        };\n    } catch (e) {\n        if (errorDiv) {\n            errorDiv.textContent = `Benchmark 2 failed: ${e.message}`;\n            errorDiv.style.display = 'block';\n        }\n        return { error: e.message };\n    } finally {\n        if (loadingDiv) loadingDiv.hidden = true;\n    }\n}\n\n\n\n\n\n\n\n\n\nCode\nbenchmark2 ? (benchmark2.error ? html`\n&lt;div style=\"background: #f8d7da; padding: 15px; border-radius: 5px; margin: 10px 0;\"&gt;\n&lt;h4 style=\"margin-top: 0;\"&gt;Benchmark 2 Error&lt;/h4&gt;\n&lt;p style=\"margin: 0;\"&gt;&lt;strong&gt;Benchmark 2 failed:&lt;/strong&gt; ${benchmark2.error}&lt;/p&gt;\n&lt;/div&gt;\n` : html`\n&lt;div style=\"background: #e7f3ff; padding: 15px; border-radius: 5px; margin: 10px 0;\"&gt;\n&lt;h4 style=\"margin-top: 0;\"&gt;${benchmark2.name}&lt;/h4&gt;\n&lt;table style=\"width: 100%; border-collapse: collapse; text-align: right;\"&gt;\n&lt;thead&gt;\n&lt;tr style=\"border-bottom: 2px solid #ccc;\"&gt;\n&lt;th style=\"text-align: left;\"&gt;Schema&lt;/th&gt;\n&lt;th&gt;Cold (1st run)&lt;/th&gt;\n&lt;th&gt;Warm (median)&lt;/th&gt;\n&lt;th&gt;All runs&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;&lt;td style=\"text-align: left;\"&gt;&lt;strong&gt;Narrow&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;${benchmark2.narrowCold.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark2.narrowMedian.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark2.narrowAll.map(t =&gt; t.toFixed(0)).join(', ')} ms&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td style=\"text-align: left;\"&gt;&lt;strong&gt;Wide&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;${benchmark2.wideCold.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark2.wideMedian.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark2.wideAll.map(t =&gt; t.toFixed(0)).join(', ')} ms&lt;/td&gt;&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p style=\"margin-bottom: 0;\"&gt;&lt;strong&gt;Speedup: ${benchmark2.speedup.toFixed(2)}x&lt;/strong&gt; (wide is ${benchmark2.speedup &gt; 1 ? 'faster' : 'slower'})&lt;/p&gt;\n&lt;/div&gt;\n`) : html`&lt;p&gt;&lt;em&gt;Waiting for benchmark...&lt;/em&gt;&lt;/p&gt;`",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#benchmark-3-material-type-distribution",
    "href": "tutorials/narrow_vs_wide_performance.html#benchmark-3-material-type-distribution",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "7 Benchmark 3: Material Type Distribution",
    "text": "7 Benchmark 3: Material Type Distribution\nThis benchmark aggregates sample counts by material category.\n\nRunning Benchmark 3…\n\n\n\nCode\nbenchmark3 = {\n    // Wait for benchmark2 to complete first (sequential execution)\n    if (runBenchmarks &lt; 1 || !benchmark2 || benchmark2.error) return null;\n\n    const loadingDiv = document.getElementById('loading_b3');\n    const errorDiv = document.getElementById('error_display');\n    if (loadingDiv) loadingDiv.hidden = false;\n\n    // Narrow query: join through edges to material concepts\n    const narrowQuery = `\n        SELECT\n            c.label as material,\n            COUNT(*) as sample_count\n        FROM narrow s\n        JOIN narrow e ON s.row_id = e.s AND e.p = 'has_material_category'\n        JOIN narrow c ON e.o[1] = c.row_id\n        WHERE s.otype = 'MaterialSampleRecord'\n        GROUP BY c.label\n        ORDER BY sample_count DESC\n        LIMIT 10\n    `;\n\n    // Wide query: direct column access to material category\n    const wideQuery = `\n        SELECT\n            c.label as material,\n            COUNT(*) as sample_count\n        FROM wide s\n        JOIN wide c ON s.p__has_material_category[1] = c.row_id\n        WHERE s.otype = 'MaterialSampleRecord'\n          AND c.otype = 'IdentifiedConcept'\n        GROUP BY c.label\n        ORDER BY sample_count DESC\n        LIMIT 10\n    `;\n\n    const runs = 3;\n\n    try {\n        // Narrow benchmark\n        const narrowTimes = [];\n        for (let i = 0; i &lt; runs; i++) {\n            const start = performance.now();\n            await dbNarrow.query(narrowQuery);\n            narrowTimes.push(performance.now() - start);\n        }\n\n        // Wide benchmark\n        const wideTimes = [];\n        for (let i = 0; i &lt; runs; i++) {\n            const start = performance.now();\n            await dbWide.query(wideQuery);\n            wideTimes.push(performance.now() - start);\n        }\n\n        const median = arr =&gt; {\n            const sorted = [...arr].sort((a, b) =&gt; a - b);\n            if (sorted.length === 2) return (sorted[0] + sorted[1]) / 2;\n            return sorted[Math.floor(sorted.length / 2)];\n        };\n        const warmMedian = arr =&gt; {\n            if (arr.length &lt;= 1) return arr[0] || 0;\n            const warm = arr.slice(1);\n            return median(warm);\n        };\n\n        const narrowMedian = warmMedian(narrowTimes);\n        const wideMedian = warmMedian(wideTimes);\n\n        return {\n            name: \"Material Type Distribution\",\n            narrowCold: narrowTimes[0],\n            narrowMedian: narrowMedian,\n            narrowAll: narrowTimes,\n            wideCold: wideTimes[0],\n            wideMedian: wideMedian,\n            wideAll: wideTimes,\n            speedup: narrowMedian / wideMedian\n        };\n    } catch (e) {\n        if (errorDiv) {\n            errorDiv.textContent = `Benchmark 3 failed: ${e.message}`;\n            errorDiv.style.display = 'block';\n        }\n        return { error: e.message };\n    } finally {\n        if (loadingDiv) loadingDiv.hidden = true;\n    }\n}\n\n\n\n\n\n\n\n\n\nCode\nbenchmark3 ? (benchmark3.error ? html`\n&lt;div style=\"background: #f8d7da; padding: 15px; border-radius: 5px; margin: 10px 0;\"&gt;\n&lt;h4 style=\"margin-top: 0;\"&gt;Benchmark 3 Error&lt;/h4&gt;\n&lt;p style=\"margin: 0;\"&gt;&lt;strong&gt;Benchmark 3 failed:&lt;/strong&gt; ${benchmark3.error}&lt;/p&gt;\n&lt;/div&gt;\n` : html`\n&lt;div style=\"background: #e7f3ff; padding: 15px; border-radius: 5px; margin: 10px 0;\"&gt;\n&lt;h4 style=\"margin-top: 0;\"&gt;${benchmark3.name}&lt;/h4&gt;\n&lt;table style=\"width: 100%; border-collapse: collapse; text-align: right;\"&gt;\n&lt;thead&gt;\n&lt;tr style=\"border-bottom: 2px solid #ccc;\"&gt;\n&lt;th style=\"text-align: left;\"&gt;Schema&lt;/th&gt;\n&lt;th&gt;Cold (1st run)&lt;/th&gt;\n&lt;th&gt;Warm (median)&lt;/th&gt;\n&lt;th&gt;All runs&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;&lt;td style=\"text-align: left;\"&gt;&lt;strong&gt;Narrow&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;${benchmark3.narrowCold.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark3.narrowMedian.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark3.narrowAll.map(t =&gt; t.toFixed(0)).join(', ')} ms&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td style=\"text-align: left;\"&gt;&lt;strong&gt;Wide&lt;/strong&gt;&lt;/td&gt;\n&lt;td&gt;${benchmark3.wideCold.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark3.wideMedian.toFixed(0)} ms&lt;/td&gt;\n&lt;td&gt;${benchmark3.wideAll.map(t =&gt; t.toFixed(0)).join(', ')} ms&lt;/td&gt;&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p style=\"margin-bottom: 0;\"&gt;&lt;strong&gt;Speedup: ${benchmark3.speedup.toFixed(2)}x&lt;/strong&gt; (wide is ${benchmark3.speedup &gt; 1 ? 'faster' : 'slower'})&lt;/p&gt;\n&lt;/div&gt;\n`) : html`&lt;p&gt;&lt;em&gt;Waiting for benchmark...&lt;/em&gt;&lt;/p&gt;`",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#results-summary",
    "href": "tutorials/narrow_vs_wide_performance.html#results-summary",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "8 Results Summary",
    "text": "8 Results Summary\n\n\nCode\nallResults = {\n    if (!benchmark1 || !benchmark2 || !benchmark3) return null;\n\n    const results = [benchmark1, benchmark2, benchmark3];\n    const successful = results.filter(r =&gt; r && !r.error);\n    const avgSpeedup = successful.length\n        ? successful.reduce((sum, r) =&gt; sum + r.speedup, 0) / successful.length\n        : null;\n\n    return {\n        benchmarks: results,\n        avgSpeedup: avgSpeedup\n    };\n}\n\nallResults ? html`\n&lt;div style=\"background: #d4edda; padding: 20px; border-radius: 5px; margin: 20px 0;\"&gt;\n&lt;h3 style=\"margin-top: 0;\"&gt;Summary Results&lt;/h3&gt;\n\n&lt;table style=\"width: 100%; border-collapse: collapse; margin-bottom: 15px;\"&gt;\n&lt;thead&gt;\n&lt;tr style=\"border-bottom: 2px solid #155724; background: #c3e6cb;\"&gt;\n&lt;th style=\"text-align: left; padding: 8px;\"&gt;Benchmark&lt;/th&gt;\n&lt;th style=\"padding: 8px;\"&gt;Narrow (ms)&lt;/th&gt;\n&lt;th style=\"padding: 8px;\"&gt;Wide (ms)&lt;/th&gt;\n&lt;th style=\"padding: 8px;\"&gt;Speedup&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n${allResults.benchmarks.map(b =&gt; {\n    const hasError = !b || b.error;\n    return html`\n&lt;tr style=\"border-bottom: 1px solid #155724;\"&gt;\n&lt;td style=\"padding: 8px;\"&gt;${b?.name || 'Benchmark'}&lt;/td&gt;\n&lt;td style=\"padding: 8px; text-align: center;\"&gt;${hasError ? 'N/A' : b.narrowMedian.toFixed(0)}&lt;/td&gt;\n&lt;td style=\"padding: 8px; text-align: center;\"&gt;${hasError ? 'N/A' : b.wideMedian.toFixed(0)}&lt;/td&gt;\n&lt;td style=\"padding: 8px; text-align: center; font-weight: bold;\"&gt;${hasError ? `Error: ${b?.error || 'Unavailable'}` : `${b.speedup.toFixed(2)}x`}&lt;/td&gt;\n&lt;/tr&gt;\n`;\n})}\n&lt;tr style=\"background: #c3e6cb; font-weight: bold;\"&gt;\n&lt;td style=\"padding: 8px;\"&gt;Average&lt;/td&gt;\n&lt;td style=\"padding: 8px; text-align: center;\"&gt;-&lt;/td&gt;\n&lt;td style=\"padding: 8px; text-align: center;\"&gt;-&lt;/td&gt;\n&lt;td style=\"padding: 8px; text-align: center;\"&gt;${allResults.avgSpeedup != null ? `${allResults.avgSpeedup.toFixed(2)}x` : 'N/A'}&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n\n&lt;h4&gt;Key Findings&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;File size reduction:&lt;/strong&gt; Wide format is 60% smaller (275 MB vs 691 MB)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Row count reduction:&lt;/strong&gt; Wide format has 79% fewer rows (~2.5M vs ~11.6M)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Query speedup:&lt;/strong&gt; ${allResults.avgSpeedup != null ? `Average ${allResults.avgSpeedup.toFixed(1)}x faster with wide format` : 'Unavailable due to benchmark errors'}&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h4&gt;Recommendation&lt;/h4&gt;\n&lt;p&gt;For browser-based analysis with DuckDB-WASM, the &lt;strong&gt;wide format is recommended&lt;/strong&gt; for:\n&lt;ul&gt;\n&lt;li&gt;Faster query execution&lt;/li&gt;\n&lt;li&gt;Reduced network transfer (fewer HTTP range requests)&lt;/li&gt;\n&lt;li&gt;Lower memory usage in the browser&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/p&gt;\n&lt;/div&gt;\n` : html`\n&lt;div style=\"background: #f0f0f0; padding: 20px; border-radius: 5px; margin: 20px 0; text-align: center;\"&gt;\n&lt;p&gt;&lt;em&gt;Click \"Run All Benchmarks\" above to see results&lt;/em&gt;&lt;/p&gt;\n&lt;/div&gt;\n`",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#technical-notes",
    "href": "tutorials/narrow_vs_wide_performance.html#technical-notes",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "9 Technical Notes",
    "text": "9 Technical Notes\n\n9.1 Pitfalls and Considerations\n\n\n\n\n\n\n\nConsideration\nHow We Address It\n\n\n\n\nBrowser caching\nFirst run is “cold” (metadata not cached), subsequent runs are “warm”\n\n\nNetwork variability\nWe run 3 iterations and report the warm-run median (exclude cold run)\n\n\nJIT compilation\nFirst run includes JIT overhead; warm runs are more representative\n\n\nMemory limits\n691 MB narrow file may stress browser memory; wide format is safer\n\n\n\n\n\n9.2 Schema Differences\nNarrow schema stores relationships as edge rows:\n-- Edge row example\n{otype: '_edge_', s: 123, p: 'produced_by', o: [456]}\nWide schema stores relationships as columns:\n-- Entity row with relationship columns\n{otype: 'MaterialSampleRecord', p__produced_by: [456], p__has_material_category: [789]}\nThis eliminates ~9M edge rows, resulting in the 60% file size reduction.",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "tutorials/narrow_vs_wide_performance.html#see-also",
    "href": "tutorials/narrow_vs_wide_performance.html#see-also",
    "title": "Narrow vs Wide Schema Performance Comparison",
    "section": "10 See Also",
    "text": "10 See Also\n\nOpenContext Parquet Analysis - Deep dive into the property graph structure\nCesium Visualization - Interactive 3D visualization of sample locations",
    "crumbs": [
      "Getting Started",
      "Narrow vs Wide Performance"
    ]
  },
  {
    "objectID": "PERFORMANCE_OPTIMIZATION_PLAN.html",
    "href": "PERFORMANCE_OPTIMIZATION_PLAN.html",
    "title": "1 Performance Optimization Plan: Cesium Tutorial",
    "section": "",
    "text": "Date: 2025-10-31 Issue: Page loading is VERY SLOW Root Cause Analysis: Multiple compounding factors\n\n\n\n\n\nLocation: parquet_cesium.qmd lines 131-157\nCurrent Behavior:\nWITH geo_classification AS (\n    SELECT\n        geo.pid, geo.latitude, geo.longitude,\n        MAX(CASE WHEN e.p = 'sample_location' THEN 1 ELSE 0 END) as is_sample_location,\n        MAX(CASE WHEN e.p = 'site_location' THEN 1 ELSE 0 END) as is_site_location\n    FROM nodes geo\n    JOIN nodes e ON (geo.row_id = e.o[1])\n    WHERE geo.otype = 'GeospatialCoordLocation'\n    GROUP BY geo.pid, geo.latitude, geo.longitude\n)\nSELECT * FROM geo_classification\nWhy It’s Slow: - Self-join of nodes table with itself on array element match (e.o[1]) - Scans ALL GeospatialCoordLocation nodes (likely thousands) - GROUP BY with aggregation (MAX + CASE) for classification - Runs BEFORE user can interact with page - DuckDB-WASM must load relevant parquet chunks via HTTP\nEstimated Impact: 🔴 80% of perceived slowness\n\n\n\n\nThree Queries (Eric’s, Path 1, Path 2) all follow this pattern:\nFROM nodes AS geo\nJOIN nodes AS rel_se ON (rel_se.p = 'sample_location' AND list_contains(rel_se.o, geo.row_id))\nJOIN nodes AS se ON (rel_se.s = se.row_id AND se.otype = 'SamplingEvent')\nJOIN nodes AS rel_site ON (se.row_id = rel_site.s AND rel_site.p = 'sampling_site')\nJOIN nodes AS site ON (rel_site.o[1] = site.row_id AND site.otype = 'SamplingSite')\nJOIN nodes AS rel_samp ON (rel_samp.p = 'produced_by' AND list_contains(rel_samp.o, se.row_id))\nJOIN nodes AS samp ON (rel_samp.s = samp.row_id AND samp.otype = 'MaterialSampleRecord')\nWHERE geo.pid = ?\nWhy It’s Slow: - 6 self-joins on the same nodes table - 2 uses of list_contains() for backward edge traversal (array scans) - Multi-hop graph traversal (5 hops: geo → event → site → event → sample) - Repeated for EACH clicked point\nEstimated Impact: 🟡 15% of perceived slowness (only after click)\n\n\n\n\nData Source: https://storage.googleapis.com/isamplesorg/data/oc_isamples_pqg.parquet\nWhy It’s Inherently Slower: - HTTP range requests for parquet chunks - Network latency (Google Cloud Storage → browser) - DuckDB-WASM must parse and cache chunks - No local indexes or materialized views\nEstimated Impact: 🟠 5% of perceived slowness (well-optimized by DuckDB already)\n\n\n\n\n\n\n\nApproach: Pre-compute the locations query result into a separate lightweight parquet file\nImplementation: 1. Server-side preprocessing: python    # Run ONCE when oc_isamples_pqg.parquet updates    import duckdb    con = duckdb.connect()    con.execute(\"\"\"        COPY (            WITH geo_classification AS (                SELECT                    geo.pid, geo.latitude, geo.longitude,                    MAX(CASE WHEN e.p = 'sample_location' THEN 1 ELSE 0 END) as is_sample_location,                    MAX(CASE WHEN e.p = 'site_location' THEN 1 ELSE 0 END) as is_site_location                FROM read_parquet('oc_isamples_pqg.parquet') geo                JOIN read_parquet('oc_isamples_pqg.parquet') e ON (geo.row_id = e.o[1])                WHERE geo.otype = 'GeospatialCoordLocation'                GROUP BY geo.pid, geo.latitude, geo.longitude            )            SELECT * FROM geo_classification        ) TO 'oc_geocodes_classified.parquet' (FORMAT PARQUET, COMPRESSION ZSTD)    \"\"\")\n\nClient-side usage:\nlocations = {\n    const query = `SELECT * FROM read_parquet('${geocodes_parquet_path}')`;\n    const data = await loadData(query, [], \"loading_1\", \"locations\");\n    // ... render points\n}\n\nExpected Speedup: ⚡ 10-50x faster initial load (from 5-10 seconds → &lt;1 second)\nTradeoffs: - ✅ Massive performance win - ✅ Simple to implement - ✅ No query rewrite needed - ⚠️ Adds one more file to maintain (~50KB vs 700MB main file) - ⚠️ Must regenerate when main parquet updates\n\n\n\n\nApproach: Let user interact with page BEFORE geocodes finish loading\nImplementation: 1. Show Cesium globe immediately (already works) 2. Display loading indicator: “Loading 1,234 geocodes…” 3. Render points in batches as they arrive (chunked processing) 4. Enable search box immediately (independent of point rendering)\nCode Pattern:\nlocations = {\n    const query = `...`; // existing query\n    const data = await loadData(query, [], \"loading_1\", \"locations\");\n\n    // Render in chunks of 500 to keep UI responsive\n    const CHUNK_SIZE = 500;\n    for (let i = 0; i &lt; data.length; i += CHUNK_SIZE) {\n        const chunk = data.slice(i, i + CHUNK_SIZE);\n        for (const row of chunk) {\n            // ... add points\n        }\n        // Yield to browser between chunks\n        await new Promise(resolve =&gt; setTimeout(resolve, 0));\n    }\n    return data;\n}\nExpected Improvement: ⚡ Perceived performance 3-5x better (page feels interactive sooner)\nTradeoffs: - ✅ Better UX without query changes - ✅ Works with existing slow query - ⚠️ More complex rendering logic - ⚠️ Doesn’t solve fundamental slowness\n\n\n\n\nApproach: Pre-build reverse lookup tables for common traversals\nImplementation: 1. Create separate index tables: ```sql – geo_to_events.parquet SELECT e.o[1] as geo_row_id, e.s as event_row_id, e.p as edge_type FROM nodes e WHERE e.p IN (‘sample_location’, ‘site_location’)\n– event_to_samples.parquet SELECT rel.o[1] as event_row_id, rel.s as sample_row_id FROM nodes rel WHERE rel.p = ‘produced_by’ ```\n\nRewrite queries to use indexes:\nSELECT samp.*, geo.latitude, geo.longitude\nFROM read_parquet('samples.parquet') samp\nJOIN read_parquet('event_to_samples.parquet') idx1 ON (samp.row_id = idx1.sample_row_id)\nJOIN read_parquet('geo_to_events.parquet') idx2 ON (idx1.event_row_id = idx2.event_row_id)\nJOIN read_parquet('geocodes.parquet') geo ON (idx2.geo_row_id = geo.row_id)\nWHERE geo.pid = ?\n\nExpected Speedup: ⚡ 5-10x faster queries (from 1-2 seconds → 200-400ms)\nTradeoffs: - ✅ Eliminates list_contains() array scans - ✅ Reduces self-joins (separate tables = better indexes) - ⚠️ Major refactor: Changes data model - ⚠️ Breaks compatibility with existing notebooks - ⚠️ More complex build pipeline\n\n\n\n\nApproach: Rewrite queries to help DuckDB optimizer\nTechniques:\n\nPush down filters earlier:\n-- BEFORE: Filter at end\nFROM nodes AS geo\nJOIN nodes AS rel_se ON (...)\nWHERE geo.pid = ?\n\n-- AFTER: Filter geo first\nFROM (SELECT * FROM nodes WHERE otype = 'GeospatialCoordLocation' AND pid = ?) AS geo\nJOIN nodes AS rel_se ON (...)\nReplace list_contains() with EXISTS subqueries (if DuckDB optimizes better):\n-- BEFORE\nJOIN nodes AS rel_se ON (list_contains(rel_se.o, geo.row_id))\n\n-- AFTER (test if faster)\nJOIN nodes AS rel_se ON (geo.row_id = ANY(rel_se.o))\nEliminate redundant JOINs:\n\nAll 3 queries join to site just for site.label and site.pid\nIf not needed for filtering, could be a separate follow-up query\n\n\nExpected Speedup: ⚡ 1.2-2x faster (marginal gains)\nTradeoffs: - ✅ No data model changes - ✅ Easy to A/B test - ⚠️ May not work due to DuckDB-WASM query planner limitations\n\n\n\n\n\n\n\nGoal: Make page feel 3-5x faster without major refactoring\n\n✅ Implement Strategy B (Lazy Loading)\n\nShow “Loading X geocodes…” progress indicator\nRender points in batches (500 at a time)\nEnable search box before points finish loading\n\n✅ Add telemetry to understand actual timings\nconsole.time('locations_query');\nconst data = await loadData(query, ...);\nconsole.timeEnd('locations_query');\n\nExpected User Experience: - Page interactive in 1-2 seconds (vs 5-10 seconds) - Visual feedback (progress bar) - Can search for specific geocode immediately\n\n\n\n\nGoal: Achieve 10-50x speedup on initial load\n\n✅ Implement Strategy A (Materialized Geocode Index)\n\nCreate oc_geocodes_classified.parquet (~50KB)\nUpdate GitHub Actions workflow to regenerate on data updates\nTest with DuckDB-WASM in browser\n\n✅ A/B Test Strategy D (SQL Micro-Optimizations)\n\nTry filter push-down\nMeasure actual impact (may be negligible)\n\n\nExpected User Experience: - Initial load: &lt;1 second for geocode points - First click query: Still 1-2 seconds (acceptable)\n\n\n\n\nGoal: Achieve 5-10x speedup on click-triggered queries\n\n⚠️ Evaluate Strategy C (Denormalized Indexes)\n\nPrototype with subset of data\nMeasure actual gains in DuckDB-WASM\nAssess maintenance burden\n\n⚠️ Consider alternative architectures:\n\nPre-compute ALL common queries → static JSON files\nClient-side caching (IndexedDB for query results)\nWebAssembly-based custom graph traversal (if DuckDB still too slow)\n\n\nOnly pursue if: Phase 2 gains aren’t sufficient for user needs\n\n\n\n\n\nBefore optimization:\n// Add to parquet_cesium.qmd\nperformance.mark('page-start');\n\nlocations = {\n    performance.mark('locations-start');\n    const data = await loadData(query, [], \"loading_1\", \"locations\");\n    performance.mark('locations-end');\n    performance.measure('locations-query', 'locations-start', 'locations-end');\n    console.log(performance.getEntriesByName('locations-query')[0].duration + 'ms');\n    return data;\n}\n\n// After first click\nasync function get_samples_1(pid) {\n    performance.mark('samples1-start');\n    const result = await loadData(q, [pid], \"loading_s1\", \"samples_1\");\n    performance.mark('samples1-end');\n    performance.measure('samples1-query', 'samples1-start', 'samples1-end');\n    console.log(performance.getEntriesByName('samples1-query')[0].duration + 'ms');\n    return result ?? [];\n}\nMetrics to Track: - Initial page load time (to interactive) - locations query execution time - First click response time (each of 3 queries) - Data transfer size (Network tab) - Memory usage (Performance tab)\n\n\n\n\n\n\nA: ~15% of the problem for initial load, ~80% for click queries\n\nInitial load: The locations query is inherently expensive (self-join + GROUP BY on all geocodes), BUT could be 10-50x faster with pre-aggregation (Strategy A)\nClick queries: The 6 self-joins are unavoidable given the property graph model, BUT could be 5-10x faster with denormalized indexes (Strategy C)\n\n\n\n\nA: We’re only stuck if we insist on querying the raw property graph\nThe property graph model REQUIRES self-joins because: - All nodes and edges in ONE table (nodes) - Graph traversal = multiple joins to the same table - No escape without changing data model\nHowever, we have options: 1. ✅ Pre-aggregate common queries (Strategy A) - avoids re-computing on every page load 2. ✅ Denormalize hot paths (Strategy C) - trades storage for query speed 3. ✅ Cache results client-side - only run expensive queries once per browser session 4. ⚠️ Abandon property graph for query layer - keep it for data ingestion, but publish separate optimized query tables\nThe self-joins are NOT the problem. The problem is: - Running expensive aggregations on EVERY page load (fixable with Strategy A) - No indexes on array-valued columns (list_contains scans) (fixable with Strategy C) - No query result caching (fixable with client-side storage)\n\n\n\n\n\nBefore proceeding, clarify:\n\nWhat’s the user’s pain threshold?\n\nIs 2 seconds initial load acceptable? (Then do Phase 1 only)\nNeed &lt;1 second? (Then do Phase 2)\nNeed instant? (Then need Phase 3 or architectural rethink)\n\nWhat’s the maintenance budget?\n\nPhase 1: Zero maintenance (just code changes)\nPhase 2: Low maintenance (regenerate one small parquet file)\nPhase 3: High maintenance (multiple derived tables, complex build pipeline)\n\nHow often does source data update?\n\nDaily: Phase 2 is fine (automated regeneration)\nHourly: Phase 3 may be problematic (cache invalidation complexity)\nWeekly: Even manual regeneration works\n\nWhat’s the priority: initial load or click response?\n\nIf initial load is the main complaint: Focus on Strategy A\nIf click queries are the main complaint: Focus on Strategy C\n\n\n\n\n\n\nImmediate Action (recommend): Start with Phase 1 to get quick wins\n\nAdd performance telemetry to quantify actual bottlenecks\nImplement lazy loading + progress indicators\nMeasure improvement\nRe-assess if Phase 2 is needed\n\nOptional: Prototype Strategy A (materialized geocode index) in parallel to see if it’s worth pursuing\nLet me know which direction you want to explore!"
  },
  {
    "objectID": "PERFORMANCE_OPTIMIZATION_PLAN.html#performance-bottlenecks-identified",
    "href": "PERFORMANCE_OPTIMIZATION_PLAN.html#performance-bottlenecks-identified",
    "title": "1 Performance Optimization Plan: Cesium Tutorial",
    "section": "",
    "text": "Location: parquet_cesium.qmd lines 131-157\nCurrent Behavior:\nWITH geo_classification AS (\n    SELECT\n        geo.pid, geo.latitude, geo.longitude,\n        MAX(CASE WHEN e.p = 'sample_location' THEN 1 ELSE 0 END) as is_sample_location,\n        MAX(CASE WHEN e.p = 'site_location' THEN 1 ELSE 0 END) as is_site_location\n    FROM nodes geo\n    JOIN nodes e ON (geo.row_id = e.o[1])\n    WHERE geo.otype = 'GeospatialCoordLocation'\n    GROUP BY geo.pid, geo.latitude, geo.longitude\n)\nSELECT * FROM geo_classification\nWhy It’s Slow: - Self-join of nodes table with itself on array element match (e.o[1]) - Scans ALL GeospatialCoordLocation nodes (likely thousands) - GROUP BY with aggregation (MAX + CASE) for classification - Runs BEFORE user can interact with page - DuckDB-WASM must load relevant parquet chunks via HTTP\nEstimated Impact: 🔴 80% of perceived slowness\n\n\n\n\nThree Queries (Eric’s, Path 1, Path 2) all follow this pattern:\nFROM nodes AS geo\nJOIN nodes AS rel_se ON (rel_se.p = 'sample_location' AND list_contains(rel_se.o, geo.row_id))\nJOIN nodes AS se ON (rel_se.s = se.row_id AND se.otype = 'SamplingEvent')\nJOIN nodes AS rel_site ON (se.row_id = rel_site.s AND rel_site.p = 'sampling_site')\nJOIN nodes AS site ON (rel_site.o[1] = site.row_id AND site.otype = 'SamplingSite')\nJOIN nodes AS rel_samp ON (rel_samp.p = 'produced_by' AND list_contains(rel_samp.o, se.row_id))\nJOIN nodes AS samp ON (rel_samp.s = samp.row_id AND samp.otype = 'MaterialSampleRecord')\nWHERE geo.pid = ?\nWhy It’s Slow: - 6 self-joins on the same nodes table - 2 uses of list_contains() for backward edge traversal (array scans) - Multi-hop graph traversal (5 hops: geo → event → site → event → sample) - Repeated for EACH clicked point\nEstimated Impact: 🟡 15% of perceived slowness (only after click)\n\n\n\n\nData Source: https://storage.googleapis.com/isamplesorg/data/oc_isamples_pqg.parquet\nWhy It’s Inherently Slower: - HTTP range requests for parquet chunks - Network latency (Google Cloud Storage → browser) - DuckDB-WASM must parse and cache chunks - No local indexes or materialized views\nEstimated Impact: 🟠 5% of perceived slowness (well-optimized by DuckDB already)"
  },
  {
    "objectID": "PERFORMANCE_OPTIMIZATION_PLAN.html#optimization-strategies",
    "href": "PERFORMANCE_OPTIMIZATION_PLAN.html#optimization-strategies",
    "title": "1 Performance Optimization Plan: Cesium Tutorial",
    "section": "",
    "text": "Approach: Pre-compute the locations query result into a separate lightweight parquet file\nImplementation: 1. Server-side preprocessing: python    # Run ONCE when oc_isamples_pqg.parquet updates    import duckdb    con = duckdb.connect()    con.execute(\"\"\"        COPY (            WITH geo_classification AS (                SELECT                    geo.pid, geo.latitude, geo.longitude,                    MAX(CASE WHEN e.p = 'sample_location' THEN 1 ELSE 0 END) as is_sample_location,                    MAX(CASE WHEN e.p = 'site_location' THEN 1 ELSE 0 END) as is_site_location                FROM read_parquet('oc_isamples_pqg.parquet') geo                JOIN read_parquet('oc_isamples_pqg.parquet') e ON (geo.row_id = e.o[1])                WHERE geo.otype = 'GeospatialCoordLocation'                GROUP BY geo.pid, geo.latitude, geo.longitude            )            SELECT * FROM geo_classification        ) TO 'oc_geocodes_classified.parquet' (FORMAT PARQUET, COMPRESSION ZSTD)    \"\"\")\n\nClient-side usage:\nlocations = {\n    const query = `SELECT * FROM read_parquet('${geocodes_parquet_path}')`;\n    const data = await loadData(query, [], \"loading_1\", \"locations\");\n    // ... render points\n}\n\nExpected Speedup: ⚡ 10-50x faster initial load (from 5-10 seconds → &lt;1 second)\nTradeoffs: - ✅ Massive performance win - ✅ Simple to implement - ✅ No query rewrite needed - ⚠️ Adds one more file to maintain (~50KB vs 700MB main file) - ⚠️ Must regenerate when main parquet updates\n\n\n\n\nApproach: Let user interact with page BEFORE geocodes finish loading\nImplementation: 1. Show Cesium globe immediately (already works) 2. Display loading indicator: “Loading 1,234 geocodes…” 3. Render points in batches as they arrive (chunked processing) 4. Enable search box immediately (independent of point rendering)\nCode Pattern:\nlocations = {\n    const query = `...`; // existing query\n    const data = await loadData(query, [], \"loading_1\", \"locations\");\n\n    // Render in chunks of 500 to keep UI responsive\n    const CHUNK_SIZE = 500;\n    for (let i = 0; i &lt; data.length; i += CHUNK_SIZE) {\n        const chunk = data.slice(i, i + CHUNK_SIZE);\n        for (const row of chunk) {\n            // ... add points\n        }\n        // Yield to browser between chunks\n        await new Promise(resolve =&gt; setTimeout(resolve, 0));\n    }\n    return data;\n}\nExpected Improvement: ⚡ Perceived performance 3-5x better (page feels interactive sooner)\nTradeoffs: - ✅ Better UX without query changes - ✅ Works with existing slow query - ⚠️ More complex rendering logic - ⚠️ Doesn’t solve fundamental slowness\n\n\n\n\nApproach: Pre-build reverse lookup tables for common traversals\nImplementation: 1. Create separate index tables: ```sql – geo_to_events.parquet SELECT e.o[1] as geo_row_id, e.s as event_row_id, e.p as edge_type FROM nodes e WHERE e.p IN (‘sample_location’, ‘site_location’)\n– event_to_samples.parquet SELECT rel.o[1] as event_row_id, rel.s as sample_row_id FROM nodes rel WHERE rel.p = ‘produced_by’ ```\n\nRewrite queries to use indexes:\nSELECT samp.*, geo.latitude, geo.longitude\nFROM read_parquet('samples.parquet') samp\nJOIN read_parquet('event_to_samples.parquet') idx1 ON (samp.row_id = idx1.sample_row_id)\nJOIN read_parquet('geo_to_events.parquet') idx2 ON (idx1.event_row_id = idx2.event_row_id)\nJOIN read_parquet('geocodes.parquet') geo ON (idx2.geo_row_id = geo.row_id)\nWHERE geo.pid = ?\n\nExpected Speedup: ⚡ 5-10x faster queries (from 1-2 seconds → 200-400ms)\nTradeoffs: - ✅ Eliminates list_contains() array scans - ✅ Reduces self-joins (separate tables = better indexes) - ⚠️ Major refactor: Changes data model - ⚠️ Breaks compatibility with existing notebooks - ⚠️ More complex build pipeline\n\n\n\n\nApproach: Rewrite queries to help DuckDB optimizer\nTechniques:\n\nPush down filters earlier:\n-- BEFORE: Filter at end\nFROM nodes AS geo\nJOIN nodes AS rel_se ON (...)\nWHERE geo.pid = ?\n\n-- AFTER: Filter geo first\nFROM (SELECT * FROM nodes WHERE otype = 'GeospatialCoordLocation' AND pid = ?) AS geo\nJOIN nodes AS rel_se ON (...)\nReplace list_contains() with EXISTS subqueries (if DuckDB optimizes better):\n-- BEFORE\nJOIN nodes AS rel_se ON (list_contains(rel_se.o, geo.row_id))\n\n-- AFTER (test if faster)\nJOIN nodes AS rel_se ON (geo.row_id = ANY(rel_se.o))\nEliminate redundant JOINs:\n\nAll 3 queries join to site just for site.label and site.pid\nIf not needed for filtering, could be a separate follow-up query\n\n\nExpected Speedup: ⚡ 1.2-2x faster (marginal gains)\nTradeoffs: - ✅ No data model changes - ✅ Easy to A/B test - ⚠️ May not work due to DuckDB-WASM query planner limitations"
  },
  {
    "objectID": "PERFORMANCE_OPTIMIZATION_PLAN.html#recommended-prioritization",
    "href": "PERFORMANCE_OPTIMIZATION_PLAN.html#recommended-prioritization",
    "title": "1 Performance Optimization Plan: Cesium Tutorial",
    "section": "",
    "text": "Goal: Make page feel 3-5x faster without major refactoring\n\n✅ Implement Strategy B (Lazy Loading)\n\nShow “Loading X geocodes…” progress indicator\nRender points in batches (500 at a time)\nEnable search box before points finish loading\n\n✅ Add telemetry to understand actual timings\nconsole.time('locations_query');\nconst data = await loadData(query, ...);\nconsole.timeEnd('locations_query');\n\nExpected User Experience: - Page interactive in 1-2 seconds (vs 5-10 seconds) - Visual feedback (progress bar) - Can search for specific geocode immediately\n\n\n\n\nGoal: Achieve 10-50x speedup on initial load\n\n✅ Implement Strategy A (Materialized Geocode Index)\n\nCreate oc_geocodes_classified.parquet (~50KB)\nUpdate GitHub Actions workflow to regenerate on data updates\nTest with DuckDB-WASM in browser\n\n✅ A/B Test Strategy D (SQL Micro-Optimizations)\n\nTry filter push-down\nMeasure actual impact (may be negligible)\n\n\nExpected User Experience: - Initial load: &lt;1 second for geocode points - First click query: Still 1-2 seconds (acceptable)\n\n\n\n\nGoal: Achieve 5-10x speedup on click-triggered queries\n\n⚠️ Evaluate Strategy C (Denormalized Indexes)\n\nPrototype with subset of data\nMeasure actual gains in DuckDB-WASM\nAssess maintenance burden\n\n⚠️ Consider alternative architectures:\n\nPre-compute ALL common queries → static JSON files\nClient-side caching (IndexedDB for query results)\nWebAssembly-based custom graph traversal (if DuckDB still too slow)\n\n\nOnly pursue if: Phase 2 gains aren’t sufficient for user needs"
  },
  {
    "objectID": "PERFORMANCE_OPTIMIZATION_PLAN.html#measurement-plan",
    "href": "PERFORMANCE_OPTIMIZATION_PLAN.html#measurement-plan",
    "title": "1 Performance Optimization Plan: Cesium Tutorial",
    "section": "",
    "text": "Before optimization:\n// Add to parquet_cesium.qmd\nperformance.mark('page-start');\n\nlocations = {\n    performance.mark('locations-start');\n    const data = await loadData(query, [], \"loading_1\", \"locations\");\n    performance.mark('locations-end');\n    performance.measure('locations-query', 'locations-start', 'locations-end');\n    console.log(performance.getEntriesByName('locations-query')[0].duration + 'ms');\n    return data;\n}\n\n// After first click\nasync function get_samples_1(pid) {\n    performance.mark('samples1-start');\n    const result = await loadData(q, [pid], \"loading_s1\", \"samples_1\");\n    performance.mark('samples1-end');\n    performance.measure('samples1-query', 'samples1-start', 'samples1-end');\n    console.log(performance.getEntriesByName('samples1-query')[0].duration + 'ms');\n    return result ?? [];\n}\nMetrics to Track: - Initial page load time (to interactive) - locations query execution time - First click response time (each of 3 queries) - Data transfer size (Network tab) - Memory usage (Performance tab)"
  },
  {
    "objectID": "PERFORMANCE_OPTIMIZATION_PLAN.html#fundamental-questions",
    "href": "PERFORMANCE_OPTIMIZATION_PLAN.html#fundamental-questions",
    "title": "1 Performance Optimization Plan: Cesium Tutorial",
    "section": "",
    "text": "A: ~15% of the problem for initial load, ~80% for click queries\n\nInitial load: The locations query is inherently expensive (self-join + GROUP BY on all geocodes), BUT could be 10-50x faster with pre-aggregation (Strategy A)\nClick queries: The 6 self-joins are unavoidable given the property graph model, BUT could be 5-10x faster with denormalized indexes (Strategy C)\n\n\n\n\nA: We’re only stuck if we insist on querying the raw property graph\nThe property graph model REQUIRES self-joins because: - All nodes and edges in ONE table (nodes) - Graph traversal = multiple joins to the same table - No escape without changing data model\nHowever, we have options: 1. ✅ Pre-aggregate common queries (Strategy A) - avoids re-computing on every page load 2. ✅ Denormalize hot paths (Strategy C) - trades storage for query speed 3. ✅ Cache results client-side - only run expensive queries once per browser session 4. ⚠️ Abandon property graph for query layer - keep it for data ingestion, but publish separate optimized query tables\nThe self-joins are NOT the problem. The problem is: - Running expensive aggregations on EVERY page load (fixable with Strategy A) - No indexes on array-valued columns (list_contains scans) (fixable with Strategy C) - No query result caching (fixable with client-side storage)"
  },
  {
    "objectID": "PERFORMANCE_OPTIMIZATION_PLAN.html#decision-points",
    "href": "PERFORMANCE_OPTIMIZATION_PLAN.html#decision-points",
    "title": "1 Performance Optimization Plan: Cesium Tutorial",
    "section": "",
    "text": "Before proceeding, clarify:\n\nWhat’s the user’s pain threshold?\n\nIs 2 seconds initial load acceptable? (Then do Phase 1 only)\nNeed &lt;1 second? (Then do Phase 2)\nNeed instant? (Then need Phase 3 or architectural rethink)\n\nWhat’s the maintenance budget?\n\nPhase 1: Zero maintenance (just code changes)\nPhase 2: Low maintenance (regenerate one small parquet file)\nPhase 3: High maintenance (multiple derived tables, complex build pipeline)\n\nHow often does source data update?\n\nDaily: Phase 2 is fine (automated regeneration)\nHourly: Phase 3 may be problematic (cache invalidation complexity)\nWeekly: Even manual regeneration works\n\nWhat’s the priority: initial load or click response?\n\nIf initial load is the main complaint: Focus on Strategy A\nIf click queries are the main complaint: Focus on Strategy C"
  },
  {
    "objectID": "PERFORMANCE_OPTIMIZATION_PLAN.html#next-steps",
    "href": "PERFORMANCE_OPTIMIZATION_PLAN.html#next-steps",
    "title": "1 Performance Optimization Plan: Cesium Tutorial",
    "section": "",
    "text": "Immediate Action (recommend): Start with Phase 1 to get quick wins\n\nAdd performance telemetry to quantify actual bottlenecks\nImplement lazy loading + progress indicators\nMeasure improvement\nRe-assess if Phase 2 is needed\n\nOptional: Prototype Strategy A (materialized geocode index) in parallel to see if it’s worth pursuing\nLet me know which direction you want to explore!"
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup document editing",
    "section": "",
    "text": "These documents are rendered using Quarto.\nSome pages use the Jupyter kernel to fetch and render content on some pages, and so python and dependencies need to be installed.\n\nInstall quarto\nCreate python virtual envronment (to avoid polluting your global environment with dependencies)\nInstall dependencies\nInstall a python kernel named “isamples-quarto”:\npython -m ipykernel install --name isamples-quarto\nRender preview using quarto preview in the root folder of this repository."
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html",
    "href": "OPTIMIZATION_SUMMARY.html",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "Date: 2025-10-31 Goal: Load map dots as quickly as possible\n\n\n\nInstead of expensive pre-computation OR slow classification on every load, we use progressive enhancement:\n\nFast initial load: Show all dots immediately (no classification)\nOptional refinement: Button to classify and color-code by type\n\n\n\n\n\n\n\n-- Expensive CTE with JOIN + GROUP BY\nWITH geo_classification AS (\n    SELECT\n        geo.pid, geo.latitude, geo.longitude,\n        MAX(CASE WHEN e.p = 'sample_location' THEN 1 ELSE 0 END) as is_sample_location,\n        MAX(CASE WHEN e.p = 'site_location' THEN 1 ELSE 0 END) as is_site_location\n    FROM nodes geo\n    JOIN nodes e ON (geo.row_id = e.o[1])\n    WHERE geo.otype = 'GeospatialCoordLocation'\n    GROUP BY geo.pid, geo.latitude, geo.longitude\n)\nSELECT pid, latitude, longitude, CASE ... END as location_type\nFROM geo_classification\nLoad Time: ~7 seconds query + 0.4s render = ~7.5 seconds total\n\n\n\n\n-- Simple DISTINCT query (no joins!)\nSELECT DISTINCT pid, latitude, longitude\nFROM nodes\nWHERE otype = 'GeospatialCoordLocation'\nLoad Time: ~1-2 seconds query + 0.4s render = ~2 seconds total 🎉\nSpeedup: 3-4x faster!\n\n\n\n\n\n\n\n\nUser navigates to page\nGlobe appears immediately\n“Loading geocodes…” (1-2 seconds)\n“Rendering geocodes… 500/198,433 (0%)” with progress bar\nAll ~198,000 dots appear in blue (single color)\nPage fully interactive in ~2 seconds\n\n\n\n\n\nUser clicks “Color-code by type (sample/site/both)” button\nClassification query runs (~7 seconds, same as old initial load)\nDots recolor:\n\nBlue (small): sample_location_only - field collection points\nPurple (large): site_location_only - administrative markers\nOrange (medium): both - dual-purpose locations\n\n\n\n\n\n\n\n\n\n\nType: Simple SELECT DISTINCT\nScan: GeospatialCoordLocation nodes only (no joins)\nTime: ~1-2 seconds (vs 7 seconds before)\nOutput: 198,433 geocodes\n\n\n\n\n\nType: CTE with JOIN + GROUP BY\nScan: Full edge traversal to determine types\nTime: ~7 seconds (same as old query, but user opted in)\nOutput: Classification map (pid → type)\nAction: Recolors existing points in-place (no re-render needed)\n\n\n\n\n\nChunk size: 500 points per batch\nYields: Every 500 points to keep browser responsive\nProgress: Dynamic indicator shows X/Y (Z%)\nTelemetry: Console logs with performance measurements\n\n\n\n\n\n\n\n\nQuery executed in 1847ms - retrieved 198433 locations\nRendering completed in 423ms\nTotal time (query + render): 2270ms\n\n\n\nClassifying dots by type...\nClassification completed in 6892ms - updated 198433 points\n  - Blue (sample_location_only): field collection points\n  - Purple (site_location_only): administrative markers\n  - Orange (both): dual-purpose locations\n\n\n\nPath 1 query executed in 1523ms - retrieved 5 samples\nPath 2 query executed in 892ms - retrieved 0 samples\nEric's query executed in 1401ms - retrieved 5 samples\n\n\n\n\n\n\n\nviewof classifyDots = Inputs.button(\"Color-code by type (sample/site/both)\", {\n  value: null,\n  reduce: () =&gt; Date.now()\n});\n\n\n\n\nRuns classification query on demand\nBuilds Map of pid → location_type\nUpdates existing point colors and sizes\nLogs telemetry to console\n\n\n\n\n\n\n\n\n\nOpen http://localhost:5860/tutorials/parquet_cesium.html\nOpen browser console (F12)\nWatch for timing logs\nExpect: ~2 seconds until all blue dots visible\n\n\n\n\n\nOnce dots are loaded, click “Color-code by type (sample/site/both)” button\nWatch console for “Classifying dots by type…” message\nExpect: Dots recolor after ~7 seconds\n\nMost dots stay blue (sample_location_only)\nSome become purple (site_location_only)\nSome become orange (both)\n\n\n\n\n\n\nClick any dot on globe\nExpect: Three tables render with sample data\nConsole shows timing for each query\n\n\n\n\n\n\n\n\n\n✅ Would also load in ~1 second\n⚠️ Requires maintenance (regenerate when source updates)\n⚠️ Requires file hosting (upload to Google Cloud Storage)\n⚠️ Another file to manage (~6MB)\n\n\n\n\n\n✅ Loads in ~2 seconds (acceptable!)\n✅ Zero maintenance (no derived files)\n✅ Zero hosting (no additional uploads)\n✅ User choice (classify only if needed)\n✅ Works with any future data updates automatically\n\n\n\n\n\n\nBefore: “This page is SO SLOW! 😩” - 7+ seconds staring at loading indicator - No feedback on progress - Browser frozen\nAfter: “Much better! The dots show up right away 👍” - ~2 seconds to interactive - Progress indicator shows work happening - Can click dots immediately - Optional classification if user wants color-coding\n\n\n\n\nIf ~2 seconds is still too slow, we can pursue:\n\n\n\nCreate oc_geocodes_simple.parquet with just pid/lat/lon\nSkip query entirely, load directly\nExpected: &lt;1 second load time\nTradeoff: Maintenance burden\n\n\n\n\n\nUse DuckDB spatial extensions\nCreate R-tree index on coordinates\nFaster viewport-based queries\nTradeoff: Complexity\n\n\n\n\n\n\nFile: tutorials/parquet_cesium.qmd\nChanges: 1. Lines 131-218: Simplified locations query (removed classification CTE) 2. Lines 50-56: Added classification button 3. Lines 769-845: Added classification handler 4. All queries: Added performance telemetry\nNet Impact: ~100 lines changed Performance Gain: 3-4x faster initial load User Benefit: Page feels responsive immediately\n\n\n\n\nBefore Optimization: - Initial load: 7+ seconds - User perception: “Slow and frozen” - Time to interactive: 7+ seconds\nAfter Optimization: - Initial load: ~2 seconds - User perception: “Fast and responsive” - Time to interactive: ~2 seconds - Improvement: 71% faster! 🎉\n\n\n\n\nThe expensive part was classification (JOIN + GROUP BY), not geocode retrieval.\nBy deferring classification to an optional button: - Fast initial load (no classification) - Progressive enhancement (classify if needed) - Zero maintenance overhead\nBest of both worlds! ✨"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#solution-implemented-progressive-enhancement",
    "href": "OPTIMIZATION_SUMMARY.html#solution-implemented-progressive-enhancement",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "Instead of expensive pre-computation OR slow classification on every load, we use progressive enhancement:\n\nFast initial load: Show all dots immediately (no classification)\nOptional refinement: Button to classify and color-code by type"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#performance-comparison",
    "href": "OPTIMIZATION_SUMMARY.html#performance-comparison",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "-- Expensive CTE with JOIN + GROUP BY\nWITH geo_classification AS (\n    SELECT\n        geo.pid, geo.latitude, geo.longitude,\n        MAX(CASE WHEN e.p = 'sample_location' THEN 1 ELSE 0 END) as is_sample_location,\n        MAX(CASE WHEN e.p = 'site_location' THEN 1 ELSE 0 END) as is_site_location\n    FROM nodes geo\n    JOIN nodes e ON (geo.row_id = e.o[1])\n    WHERE geo.otype = 'GeospatialCoordLocation'\n    GROUP BY geo.pid, geo.latitude, geo.longitude\n)\nSELECT pid, latitude, longitude, CASE ... END as location_type\nFROM geo_classification\nLoad Time: ~7 seconds query + 0.4s render = ~7.5 seconds total\n\n\n\n\n-- Simple DISTINCT query (no joins!)\nSELECT DISTINCT pid, latitude, longitude\nFROM nodes\nWHERE otype = 'GeospatialCoordLocation'\nLoad Time: ~1-2 seconds query + 0.4s render = ~2 seconds total 🎉\nSpeedup: 3-4x faster!"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#user-experience-flow",
    "href": "OPTIMIZATION_SUMMARY.html#user-experience-flow",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "User navigates to page\nGlobe appears immediately\n“Loading geocodes…” (1-2 seconds)\n“Rendering geocodes… 500/198,433 (0%)” with progress bar\nAll ~198,000 dots appear in blue (single color)\nPage fully interactive in ~2 seconds\n\n\n\n\n\nUser clicks “Color-code by type (sample/site/both)” button\nClassification query runs (~7 seconds, same as old initial load)\nDots recolor:\n\nBlue (small): sample_location_only - field collection points\nPurple (large): site_location_only - administrative markers\nOrange (medium): both - dual-purpose locations"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#technical-details",
    "href": "OPTIMIZATION_SUMMARY.html#technical-details",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "Type: Simple SELECT DISTINCT\nScan: GeospatialCoordLocation nodes only (no joins)\nTime: ~1-2 seconds (vs 7 seconds before)\nOutput: 198,433 geocodes\n\n\n\n\n\nType: CTE with JOIN + GROUP BY\nScan: Full edge traversal to determine types\nTime: ~7 seconds (same as old query, but user opted in)\nOutput: Classification map (pid → type)\nAction: Recolors existing points in-place (no re-render needed)\n\n\n\n\n\nChunk size: 500 points per batch\nYields: Every 500 points to keep browser responsive\nProgress: Dynamic indicator shows X/Y (Z%)\nTelemetry: Console logs with performance measurements"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#console-output-examples",
    "href": "OPTIMIZATION_SUMMARY.html#console-output-examples",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "Query executed in 1847ms - retrieved 198433 locations\nRendering completed in 423ms\nTotal time (query + render): 2270ms\n\n\n\nClassifying dots by type...\nClassification completed in 6892ms - updated 198433 points\n  - Blue (sample_location_only): field collection points\n  - Purple (site_location_only): administrative markers\n  - Orange (both): dual-purpose locations\n\n\n\nPath 1 query executed in 1523ms - retrieved 5 samples\nPath 2 query executed in 892ms - retrieved 0 samples\nEric's query executed in 1401ms - retrieved 5 samples"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#ui-components-added",
    "href": "OPTIMIZATION_SUMMARY.html#ui-components-added",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "viewof classifyDots = Inputs.button(\"Color-code by type (sample/site/both)\", {\n  value: null,\n  reduce: () =&gt; Date.now()\n});\n\n\n\n\nRuns classification query on demand\nBuilds Map of pid → location_type\nUpdates existing point colors and sizes\nLogs telemetry to console"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#testing-instructions",
    "href": "OPTIMIZATION_SUMMARY.html#testing-instructions",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "Open http://localhost:5860/tutorials/parquet_cesium.html\nOpen browser console (F12)\nWatch for timing logs\nExpect: ~2 seconds until all blue dots visible\n\n\n\n\n\nOnce dots are loaded, click “Color-code by type (sample/site/both)” button\nWatch console for “Classifying dots by type…” message\nExpect: Dots recolor after ~7 seconds\n\nMost dots stay blue (sample_location_only)\nSome become purple (site_location_only)\nSome become orange (both)\n\n\n\n\n\n\nClick any dot on globe\nExpect: Three tables render with sample data\nConsole shows timing for each query"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#why-this-approach-wins",
    "href": "OPTIMIZATION_SUMMARY.html#why-this-approach-wins",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "✅ Would also load in ~1 second\n⚠️ Requires maintenance (regenerate when source updates)\n⚠️ Requires file hosting (upload to Google Cloud Storage)\n⚠️ Another file to manage (~6MB)\n\n\n\n\n\n✅ Loads in ~2 seconds (acceptable!)\n✅ Zero maintenance (no derived files)\n✅ Zero hosting (no additional uploads)\n✅ User choice (classify only if needed)\n✅ Works with any future data updates automatically"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#expected-user-satisfaction",
    "href": "OPTIMIZATION_SUMMARY.html#expected-user-satisfaction",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "Before: “This page is SO SLOW! 😩” - 7+ seconds staring at loading indicator - No feedback on progress - Browser frozen\nAfter: “Much better! The dots show up right away 👍” - ~2 seconds to interactive - Progress indicator shows work happening - Can click dots immediately - Optional classification if user wants color-coding"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#future-optimizations-if-needed",
    "href": "OPTIMIZATION_SUMMARY.html#future-optimizations-if-needed",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "If ~2 seconds is still too slow, we can pursue:\n\n\n\nCreate oc_geocodes_simple.parquet with just pid/lat/lon\nSkip query entirely, load directly\nExpected: &lt;1 second load time\nTradeoff: Maintenance burden\n\n\n\n\n\nUse DuckDB spatial extensions\nCreate R-tree index on coordinates\nFaster viewport-based queries\nTradeoff: Complexity"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#code-changes-summary",
    "href": "OPTIMIZATION_SUMMARY.html#code-changes-summary",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "File: tutorials/parquet_cesium.qmd\nChanges: 1. Lines 131-218: Simplified locations query (removed classification CTE) 2. Lines 50-56: Added classification button 3. Lines 769-845: Added classification handler 4. All queries: Added performance telemetry\nNet Impact: ~100 lines changed Performance Gain: 3-4x faster initial load User Benefit: Page feels responsive immediately"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#success-metrics",
    "href": "OPTIMIZATION_SUMMARY.html#success-metrics",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "Before Optimization: - Initial load: 7+ seconds - User perception: “Slow and frozen” - Time to interactive: 7+ seconds\nAfter Optimization: - Initial load: ~2 seconds - User perception: “Fast and responsive” - Time to interactive: ~2 seconds - Improvement: 71% faster! 🎉"
  },
  {
    "objectID": "OPTIMIZATION_SUMMARY.html#key-insight",
    "href": "OPTIMIZATION_SUMMARY.html#key-insight",
    "title": "1 Cesium Tutorial Performance Optimization - Final Implementation",
    "section": "",
    "text": "The expensive part was classification (JOIN + GROUP BY), not geocode retrieval.\nBy deferring classification to an optional button: - Fast initial load (no classification) - Progressive enhancement (classify if needed) - Zero maintenance overhead\nBest of both worlds! ✨"
  },
  {
    "objectID": "models/generated/extensions/readme.html",
    "href": "models/generated/extensions/readme.html",
    "title": "iSamples",
    "section": "",
    "text": "this folder contains markdown output for extension vocabularies"
  },
  {
    "objectID": "models/namespaces.html",
    "href": "models/namespaces.html",
    "title": "1 Namespaces defined by iSamples",
    "section": "",
    "text": "Namespaces are used to uniquely address resources offered by the project.\nIn order to support introspection, all namespace IRIs are to be resolvable. Resolution involves three variables: the IRI, the requested content type, and an optional profile.\nThe IRI provides the location of the resource. Reference to specific items within a resource can be made in two ways: by path (e.g. /resource/element) and by fragment (e.g. resource#element). IRI fragments are not transmitted to a server by a client, hence a fragment identifier is always relative to the retrieved document. The basic rule is thus, the path element reference is used to reference a specific document, then a fragment is used to reference a specific component of the document.\nThe requested content type is presented by a client in the Accept header. If no Accept header is presented by the client or the Accept header is ambiguous (e.g. */*), then the default content type is returned. If a specific content type can not be matched, then a 406 Not Acceptable status is returned.\n\n\n\nIRI\n\nhttps://w3id.org/isamples/\n\n\nThe namespace base provides the root for project IRIs. The project will utilize the w3id.org infrastructure to enable abstraction of the advertised location and the physical location of the resource. Such abstraction is especially important early in the project as locations of resources are in flux.\n\n\n\nThe default format for definitions is JSON-LD. Other formats may be requested using the Accept header.\n\nIRI\n\niss: &lt;https://w3id.org/isamples/models/&gt;\n\n\nDefinitions include static content such as vocabularies, ontologies, schemas, and other documents providing machine and human actionable documents describing resources.\n\nVocabularies\n\nhttps://w3id.org/isamples/models/vocab/\n\nSpecimen Type Vocabulary:\n\nhttps://w3id.org/isamples/models/vocab/specimen_type/\n\nSampled Feature Vocabulary:\n\nhttps://w3id.org/isamples/models/vocab/sampled_feature/\n\nMaterial Type Vocabulary:\n\nhttps://w3id.org/isamples/models/vocab/material_type/\n\n\n\n\n\n\nIRI\n\nhttps://w3id.org/isamples/svc/\n\n\n\n\n\nIRI\n\nhttps://w3id.org/isamples/svc/meta/"
  },
  {
    "objectID": "models/namespaces.html#namespace-base",
    "href": "models/namespaces.html#namespace-base",
    "title": "1 Namespaces defined by iSamples",
    "section": "",
    "text": "IRI\n\nhttps://w3id.org/isamples/\n\n\nThe namespace base provides the root for project IRIs. The project will utilize the w3id.org infrastructure to enable abstraction of the advertised location and the physical location of the resource. Such abstraction is especially important early in the project as locations of resources are in flux."
  },
  {
    "objectID": "models/namespaces.html#definitions",
    "href": "models/namespaces.html#definitions",
    "title": "1 Namespaces defined by iSamples",
    "section": "",
    "text": "The default format for definitions is JSON-LD. Other formats may be requested using the Accept header.\n\nIRI\n\niss: &lt;https://w3id.org/isamples/models/&gt;\n\n\nDefinitions include static content such as vocabularies, ontologies, schemas, and other documents providing machine and human actionable documents describing resources.\n\nVocabularies\n\nhttps://w3id.org/isamples/models/vocab/\n\nSpecimen Type Vocabulary:\n\nhttps://w3id.org/isamples/models/vocab/specimen_type/\n\nSampled Feature Vocabulary:\n\nhttps://w3id.org/isamples/models/vocab/sampled_feature/\n\nMaterial Type Vocabulary:\n\nhttps://w3id.org/isamples/models/vocab/material_type/"
  },
  {
    "objectID": "models/namespaces.html#services",
    "href": "models/namespaces.html#services",
    "title": "1 Namespaces defined by iSamples",
    "section": "",
    "text": "IRI\n\nhttps://w3id.org/isamples/svc/\n\n\n\n\n\nIRI\n\nhttps://w3id.org/isamples/svc/meta/"
  },
  {
    "objectID": "models/mapping_sources.html",
    "href": "models/mapping_sources.html",
    "title": "Mapping Source Records",
    "section": "",
    "text": "In general the process is :\nRemove plantuml diagram… [smr 2024-01-04]"
  },
  {
    "objectID": "models/mapping_sources.html#mapping-from-sources-to-core",
    "href": "models/mapping_sources.html#mapping-from-sources-to-core",
    "title": "Mapping Source Records",
    "section": "",
    "text": "In general the process is :\nRemove plantuml diagram… [smr 2024-01-04]"
  },
  {
    "objectID": "models/mapping_sources.html#geome",
    "href": "models/mapping_sources.html#geome",
    "title": "Mapping Source Records",
    "section": "2 GEOME",
    "text": "2 GEOME\n\n\n\ns\np\no\nLabel\nSource\n\n\n\n\nARK\nhas_record\n_id\nevent\nGEOME\n\n\nARK\nhas_record\n_id\nsample\nGEOME\n\n\nARK\nhas_record\n_id\ntissue\nGEOME\n\n\nIGSN\nhas_record\n_id\nsample\nSESAR\n\n\nARK\nhas_record\n_id\nSMITHSONIAN\n\n\n\n\n\n\n\n```xhhweboe assets/geome_mapping.drawio.svg\n\n\n\n\nalign: left\n\n\n\nSource record representation.\n\n```{figure} assets/geome_mapping_1.drawio.svg\n---\nalign: left\n---\nMapping to individual core records and relation records. \nRelations between entities are modelled as triples with subject (s) indicating the source of the relation, the predicate (p) the type of relation, and object (o) identifying the target.\n\n\n\n```xhhweboe assets/geome_mapping_2.drawio.svg\n\n\n\n\nalign: left\n\n\n\nMapping to individual core records and including relations in the records. ```\nRelations between entities are modelled as key-value pairs within the record, with key being a field name, and value being a list of identifiers."
  },
  {
    "objectID": "models/index.html",
    "href": "models/index.html",
    "title": "iSamples Vocabularies",
    "section": "",
    "text": "see description of model at https://isamplesorg.github.io/metadata/",
    "crumbs": [
      "Information Architecture",
      "iSamples Vocabularies"
    ]
  },
  {
    "objectID": "models/index.html#taxonomies",
    "href": "models/index.html#taxonomies",
    "title": "iSamples Vocabularies",
    "section": "Taxonomies",
    "text": "Taxonomies\nOne of the foundations for interoperability of iSamples material sample descriptions is the definition of vocabularies for the categorization of sample type. There are three core vocabularies for different aspects of sample type: material sample type, material type, and sampled feature type. Each vocabulary is maintained as an RDF file using the SKOS vocabulary, with hierarchical relationships using SKOS:broader. In order to be domain agnostic, these core taxonomies cover a small set of top level terms. The taxonomies may be extended as necessary to support more specialized domains by relating additional terms using SKOS:broader and SKOS:narrower.\nThe iSamples core taxonomies are controlled vocabularies with terms related by SKOS:broader and SKOS:narrower. In order to be domain agnostic, the core taxonomies cover a small set of top level terms. The taxonomies may be extended as necessary to support more specialized domains by relating additional terms using SKOS:broader and SKOS:narrower.\nThe iSamples taxonomies are used to characterize three fundamental concepts pertaining to physical samples:\n\nThe “iSamples Materials vocabulary” is a taxonomy of terms used to categorize the composition of a physical sample, that is “What material is the sample composed of?”\nThe “Sampled Feature Type Vocabulary” is a taxonomy of terms used to indicate what the sample is representative of.\nThe “iSamples Specimen Type Vocabulary” is a taxonomy of broad categories that classify what type of spcimen the physical sample record represents.\n\nThree taxonomies are currently defined :\nMaterial Sample (specimen) Type Vocabulary\nMaterials Vocabulary\nSampled Feature (context) Type vocabulary",
    "crumbs": [
      "Information Architecture",
      "iSamples Vocabularies"
    ]
  },
  {
    "objectID": "models/generated/vocabularies/readme.html",
    "href": "models/generated/vocabularies/readme.html",
    "title": "iSamples",
    "section": "",
    "text": "target for generated markdwon files. Quarto does not render readme files."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Internet of Samples: iSamples",
    "section": "",
    "text": "The Internet of Samples (iSamples) is a multi-disciplinary and multi-institutional project funded by the National Science Foundation to design, develop, and promote service infrastructure to uniquely, consistently, and conveniently identify material samples, record metadata about them, and persistently link them to other samples and derived digital content, including images, data, and publications.\n\nCurrent Data Access: Geoparquet-Based Approach\nNote: iSamples Central is currently unavailable. The project now uses geoparquet files for efficient, browser-based data access and analysis:\n📊    Interactive Tutorials - Modern browser-based analysis with DuckDB-WASM  🗺️    Comprehensive Coverage - Complete datasets from SESAR, OpenContext, GEOME, and Smithsonian  🚀    High Performance - Fast, efficient data access with minimal memory usage  🌐    Universal Access - Works in any modern browser without software installation"
  },
  {
    "objectID": "pubs.html",
    "href": "pubs.html",
    "title": "Publications",
    "section": "",
    "text": "TODO:\n\nFigure out grouping by reference type\nAutomate update of the .bib file\nAdjust the bib stlye\n\n\n\n1. Davies N, Deck J, Kansa EC, Kansa SW, Kunze J, Meyer C, Orrell T, Ramdeen S, Snyder R, Vieglais D, Walls RL, Lehnert K (2021) Internet of Samples (iSamples): Toward an interdisciplinary cyberinfrastructure for material samples. GigaScience, 10(5)https://doi.org/10.1093/gigascience/giab028",
    "crumbs": [
      "Outputs",
      "Publications"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About iSamples",
    "section": "",
    "text": "Design and develop iSamples infrastructure (iSamples in a Box and distributed data systems);\nBuild four initial implementations of iSamples for adoption and use case testing (Open Context, GEOME, SESAR, and Smithsonian Institution);\nConduct outreach and community engagement to developers, individual researchers, and international organizations concerned with material samples.\n\n\n\nNote: iSamples Central is currently unavailable. The project has transitioned to a geoparquet-based approach for data access and analysis:\n\nPrimary Data Source: Comprehensive geoparquet files containing millions of sample records\nAnalysis Platform: Browser-based tools using DuckDB-WASM and Observable\nCoverage: Complete datasets from SESAR, OpenContext, GEOME, and Smithsonian collections\n\n\n\n\niSamples diagram",
    "crumbs": [
      "Goals"
    ]
  },
  {
    "objectID": "about.html#current-data-access",
    "href": "about.html#current-data-access",
    "title": "About iSamples",
    "section": "",
    "text": "Note: iSamples Central is currently unavailable. The project has transitioned to a geoparquet-based approach for data access and analysis:\n\nPrimary Data Source: Comprehensive geoparquet files containing millions of sample records\nAnalysis Platform: Browser-based tools using DuckDB-WASM and Observable\nCoverage: Complete datasets from SESAR, OpenContext, GEOME, and Smithsonian collections\n\n\n\n\niSamples diagram",
    "crumbs": [
      "Goals"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium_split.html",
    "href": "tutorials/parquet_cesium_split.html",
    "title": "Using Cesium for display of remote parquet.",
    "section": "",
    "text": "This page renders points from an iSamples parquet file on cesium using point primitives.\nIn this case, the Open Context source has been split into separate nodes and edges parquet files, with the edges table containing only s, p, and un-nested o for _edge_ rows, and the same content removed from the nodes table.\nThe resulting files sizes are smaller at about 58 and 236 mb for edges and nodes respectively.\nThis page loads the entire edges file, but keeps the nodes resource remote only. The initial query when clicking on a point is a bit slow, but performance should improve significantly for subsequent interactions.\n\n\n\n\nCesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwNzk3NjkyMy1iNGI1LTRkN2UtODRiMy04OTYwYWE0N2M3ZTkiLCJpZCI6Njk1MTcsImlhdCI6MTYzMzU0MTQ3N30.e70dpNzOCDRLDGxRguQCC-tRzGzA-23Xgno5lNgCeB4';\n\n\n\n\n\n\n\nviewof nodes_path = Inputs.text({\n    label:\"Source\", \n    value:\"https://s3.beehivebeach.com/isamples-data/oc_nodes.parquet\", \n    width:\"100%\", \n    submit:true\n});\nviewof edges_path = Inputs.text({\n    label:\"Source\", \n    value:\"https://s3.beehivebeach.com/isamples-data/oc_edge.parquet\", \n    width:\"100%\", \n    submit:true\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndb = {\n  const instance = await DuckDBClient.of();\n  await instance.query(`create view nodes as select * from read_parquet('${nodes_path}')`);\n  instance.query(`create table edges as select s,p,o from read_parquet('${edges_path}')`);\n  return instance;\n}\n\n\nasync function loadData(query, params=[], waiting_id=null) {\n    // Get loading indicator\n    const waiter = document.getElementById(waiting_id);\n    if (waiter) {\n        waiter.hidden = false;\n    }\n    try {\n        // Run the (slow) query\n        const _results = await db.query(query, ...params);\n        return _results;\n    } catch (error) {\n        if (waiter) {\n            waiter.innerHtml = `&lt;pre&gt;${error}&lt;/pre&gt;`;\n        }\n        return null;\n    } finally {\n        // Hide the waiter (if there is one)\n        if (waiter) {\n            waiter.hidden = true;\n        }\n    }\n}\n\nlocations = {\n    // get the content form the parquet file\n    const query = `SELECT pid, latitude, longitude FROM nodes WHERE otype='GeospatialCoordLocation'`;\n    const data = await loadData(query, [], \"loading_1\");\n\n    // Clear the existing PointPrimitiveCollection\n    content.points.removeAll();\n    //content.points = new Cesium.PointPrimitiveCollection();\n\n    // create point primitives for cesium display\n    const scalar = new Cesium.NearFarScalar(1.5e2, 2, 8.0e6, 0.2);\n    const color = Cesium.Color.PINK;\n    const point_size = 4;\n    for (const row of data) {\n        content.points.add({\n            id: row.pid,\n            // https://cesium.com/learn/cesiumjs/ref-doc/Cartesian3.html#.fromDegrees\n            position: Cesium.Cartesian3.fromDegrees(\n                row.longitude,  //longitude\n                row.latitude,   //latitude\n                0,//randomCoordinateJitter(10.0, 10.0), //elevation, m\n            ),\n            pixelSize: point_size,\n            color: color,\n            scaleByDistance: scalar,\n        });\n    }\n    content.enableTracking();\n    return data;\n}\n\n\nfunction createShowPrimitive(viewer) {\n    return function(movement) {\n        // Get the point at the mouse end position\n        const selectPoint = viewer.viewer.scene.pick(movement.endPosition);        \n\n        // Clear the current selection, if there is one and it is different to the selectPoint\n        if (viewer.currentSelection !== null) {\n            //console.log(`selected.p ${viewer.currentSelection}`)\n            if (Cesium.defined(selectPoint) && selectPoint !== viewer.currentSelection) {\n                console.log(`selected.p 2 ${viewer.currentSelection}`)\n                viewer.currentSelection.primitive.pixelSize = 4;\n                viewer.currentSelection.primitive.outlineColor = Cesium.Color.TRANSPARENT;\n                viewer.currentSelection.outlineWidth = 0;\n                viewer.currentSelection = null;\n            }\n        }\n\n        // If selectPoint is valid and no currently selected point\n        if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n            //console.log(`showPrimitiveId ${selectPoint.id}`);\n            //const carto = Cesium.Cartographic.fromCartesian(selectPoint.primitive.position)\n            viewer.pointLabel.position = selectPoint.primitive.position;\n            viewer.pointLabel.label.show = true;\n            //viewer.pointLabel.label.text = `id:${selectPoint.id}, ${carto}`;\n            viewer.pointLabel.label.text = `${selectPoint.id}`;\n            selectPoint.primitive.pixelSize = 20;\n            selectPoint.primitive.outlineColor = Cesium.Color.YELLOW;\n            selectPoint.primitive.outlineWidth = 3;\n            viewer.currentSelection = selectPoint;\n        } else {\n            viewer.pointLabel.label.show = false;\n        }            \n    }\n}\n\nclass CView {\n    constructor(target) {\n        this.viewer = new Cesium.Viewer(\n            target, {\n                timeline: false,\n                animation: false,\n                baseLayerPicker: false,\n                fullscreenElement: target,\n                terrain: Cesium.Terrain.fromWorldTerrain()\n            });\n        this.currentSelection = null;\n        this.point_size = 1;\n        this.n_points = 0;\n        // https://cesium.com/learn/cesiumjs/ref-doc/PointPrimitiveCollection.html\n        this.points = new Cesium.PointPrimitiveCollection();\n        this.viewer.scene.primitives.add(this.points);\n     \n        this.pointLabel = this.viewer.entities.add({\n            label: {\n            show: false,\n            showBackground: true,\n            font: \"14px monospace\",\n            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,\n            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,\n            pixelOffset: new Cesium.Cartesian2(15, 0),\n            // this attribute will prevent this entity clipped by the terrain\n            disableDepthTestDistance: Number.POSITIVE_INFINITY,\n            text:\"\",\n            },\n        });\n\n        this.pickHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        // Can also do this rather than wait for the points to be generated\n        //this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n\n        this.selectHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        this.selectHandler.setInputAction((e) =&gt; {\n            const selectPoint = this.viewer.scene.pick(e.position);\n            if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n                mutable clickedPointId = selectPoint.id;\n            }\n        },Cesium.ScreenSpaceEventType.LEFT_CLICK);\n\n    }\n\n    enableTracking() {\n        this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n    }\n}\n\ncontent = new CView(\"cesiumContainer\");\n\nasync function getGeoRecord(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return \"unset\";\n    }\n    const q = `SELECT row_id, pid, otype, latitude, longitude FROM nodes WHERE otype='GeospatialCoordLocation' AND pid=?`;\n    const result = await db.queryRow(q, [pid]);\n    return result;\n}\n\nasync function locationUsedBy(rowid){\n    if (rowid === undefined || rowid === null) {\n        return [];\n    }\n    const q = `select pid, otype from nodes where row_id in (select edges.s from edges where edges.o=?);`;\n    return db.query(q, [rowid]);\n}\n\nasync function samplesAtLocation(rowid) {\n    if (rowid === undefined || rowid === null) {\n        return [];\n    }\n    const q = `select pid, label, description from nodes where row_id in (\n    with recursive efor(s,p,o) as (\n        select s,p,o from edges where o=? \n        union all\n        select e.s, e.p, e.o from edges as e, efor as ef where ef.s = e.o\n    ) select s from efor where p='produced_by');`;\n    return db.query(q, [rowid]);\n}\n\nmutable clickedPointId = \"unset\";\nselectedGeoRecord = await getGeoRecord(clickedPointId);\n\nmd`Retrieved ${pointdata.length} locations from ${nodes_path}.`;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMapData\n\n\n\n\n\n\n\n\nLoading…\n\n\n\nCode\nviewof pointdata = {\n    const data_table = Inputs.table(locations, {\n        header: {\n            row_id:\"Row ID\",\n            pid: \"PID\",\n            latitude: \"Latitude\",\n            longitude: \"Longitude\"\n        },\n    });\n    return data_table;\n}\n\n\n\n\n\n\n\n\n\n\nThe click point ID is “”.\n\nmd`\\`\\`\\`\n${JSON.stringify(selectedGeoRecord, null, 2)}\n\\`\\`\\`\n`\n\n\n\n\n\n\n\nInputs.table(locationUsedBy(selectedGeoRecord.row_id));\n\n\n\n\n\n\n\nviewof usedby = {\n    const table = Inputs.table(samplesAtLocation(selectedGeoRecord.row_id));\n    return table;\n}",
    "crumbs": [
      "Getting Started",
      "Cesium View split sources"
    ]
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials: Overview",
    "section": "",
    "text": "Welcome to the iSamples tutorials! These tutorials demonstrate how to work with sample data using modern browser-based tools and geoparquet files.",
    "crumbs": [
      "Getting Started",
      "iSamples Tutorials Overview"
    ]
  },
  {
    "objectID": "tutorials/index.html#available-data-sources",
    "href": "tutorials/index.html#available-data-sources",
    "title": "Tutorials: Overview",
    "section": "1 Available Data Sources",
    "text": "1 Available Data Sources\nWith iSamples Central currently unavailable, all tutorials now use geoparquet files as the primary data source:\n\n1.1 Primary Data Sources\n\nZenodo Complete Dataset: ~300MB, 6+ million records from all iSamples sources\nOpenContext Parquet: Curated archaeological sample data\nDomain-specific Collections: Specialized datasets for focused analysis\n\n\n\n1.2 Tutorial Categories\n🗺️ Geographic Analysis - Interactive mapping and spatial exploration - Regional distribution analysis - Cesium-based 3D visualizations\n📊 Data Analysis - Statistical analysis with DuckDB-WASM - Material category distributions - Cross-collection comparisons\n🚀 Performance Demonstrations - Browser-based big data analysis - Efficient sampling and visualization techniques - HTTP range request optimization",
    "crumbs": [
      "Getting Started",
      "iSamples Tutorials Overview"
    ]
  },
  {
    "objectID": "tutorials/index.html#why-geoparquet",
    "href": "tutorials/index.html#why-geoparquet",
    "title": "Tutorials: Overview",
    "section": "2 Why Geoparquet?",
    "text": "2 Why Geoparquet?\nOur tutorials showcase how geoparquet + DuckDB-WASM enables:\n\n✅ Universal access: No software installation required\n✅ Fast analysis: 5-10x faster than traditional approaches (e.g., downloading full CSV datasets and analyzing them locally). See benchmark\n✅ Memory efficient: Analyze 300MB datasets using &lt;100MB browser memory\n✅ Minimal data transfer: Only download what you need\n✅ Interactive exploration: Real-time parameter adjustment",
    "crumbs": [
      "Getting Started",
      "iSamples Tutorials Overview"
    ]
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html",
    "href": "tutorials/oc_parquet_enhanced.html",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "",
    "text": "This document provides an enhanced analysis of the OpenContext iSamples parquet file, demonstrating the property graph structure and how to work with archaeological specimen data."
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#understanding-the-property-graph-structure",
    "href": "tutorials/oc_parquet_enhanced.html#understanding-the-property-graph-structure",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "1 Understanding the Property Graph Structure",
    "text": "1 Understanding the Property Graph Structure\nThe OpenContext iSamples parquet file implements a sophisticated property graph model that combines the flexibility of graph databases with the analytical performance of columnar storage. Unlike traditional relational databases or pure graph databases, this approach stores both entities (nodes) and relationships (edges) in a single table structure.\n\n1.1 Why a Property Graph?\nArchaeological and specimen data inherently forms a network:\n\nSamples are collected at sites during events\nSites have geographic locations\nSamples have material types from controlled vocabularies\nPeople (agents) have various roles in the collection process\n\nThis interconnected nature makes a graph model ideal for representing the complex relationships while maintaining query performance."
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#setup",
    "href": "tutorials/oc_parquet_enhanced.html#setup",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "2 Setup",
    "text": "2 Setup\n\n\nCode\n// Import DuckDB for browser-based SQL analysis\nimport { DuckDBClient } from \"https://cdn.jsdelivr.net/npm/@observablehq/duckdb@latest/+esm\"\n\n\n\n\n\n\n\n\n\nCode\nviewof parquet_path = Inputs.text({\n    label: \"Parquet File URL\",\n    value: \"https://storage.googleapis.com/opencontext-parquet/oc_isamples_pqg.parquet\",\n    width: \"100%\",\n    submit: true\n});\n\n\n\n\n\n\n\n\n\nCode\ndb = {\n    const instance = await DuckDBClient.of();\n    await instance.query(`CREATE VIEW nodes AS SELECT * FROM read_parquet('${parquet_path}')`);\n    return instance;\n}\n\n// Helper function for loading data with visual feedback\nasync function loadData(query, params=[], waiting_id=null) {\n    const waiter = document.getElementById(waiting_id);\n    if (waiter) {\n        waiter.hidden = false;\n    }\n    try {\n        const _results = await db.query(query, ...params);\n        return _results;\n    } catch (error) {\n        if (waiter) {\n            waiter.innerHTML = `&lt;pre&gt;${error}&lt;/pre&gt;`;\n        }\n        return null;\n    } finally {\n        if (waiter) {\n            waiter.hidden = true;\n        }\n    }\n}"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#data-model-deep-dive",
    "href": "tutorials/oc_parquet_enhanced.html#data-model-deep-dive",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "3 Data Model Deep Dive",
    "text": "3 Data Model Deep Dive\n\n3.1 Entity Types in the Dataset\nThe parquet file contains 7 distinct object types (otype), each serving a specific purpose in the archaeological data model:\n\n\nCode\nentityTypeDescriptions = {\n    return [\n        {otype: \"_edge_\", purpose: \"Relationships between entities\", icon: \"🔗\"},\n        {otype: \"MaterialSampleRecord\", purpose: \"Physical samples/specimens\", icon: \"🪨\"},\n        {otype: \"SamplingEvent\", purpose: \"When/how samples were collected\", icon: \"📅\"},\n        {otype: \"GeospatialCoordLocation\", purpose: \"Geographic coordinates\", icon: \"📍\"},\n        {otype: \"SamplingSite\", purpose: \"Archaeological sites/dig locations\", icon: \"🏛️\"},\n        {otype: \"IdentifiedConcept\", purpose: \"Controlled vocabulary terms\", icon: \"📚\"},\n        {otype: \"Agent\", purpose: \"People and organizations\", icon: \"👤\"}\n    ];\n}\n\nviewof entityTypeTable = Inputs.table(entityTypeDescriptions, {\n    header: {\n        otype: \"Entity Type\",\n        purpose: \"Purpose\",\n        icon: \"Icon\"\n    }\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2 Entity Distribution\n\n\nCode\nentityStats = {\n    const query = `\n        SELECT\n            otype,\n            COUNT(*) as count,\n            ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) as percentage\n        FROM nodes\n        GROUP BY otype\n        ORDER BY count DESC\n    `;\n    const data = await loadData(query, [], \"loading_entity_stats\");\n    return data;\n}\n\n\n\n\n\n\n\n\nLoading entity statistics…\n\n\n\nCode\nviewof entityStatsTable = Inputs.table(entityStats, {\n    header: {\n        otype: \"Entity Type\",\n        count: \"Count\",\n        percentage: \"Percentage\"\n    },\n    format: {\n        count: d =&gt; d.toLocaleString(),\n        percentage: d =&gt; d + \"%\"\n    }\n})\n\n\n\n\n\n\n\nTotal records: \n\n\n3.3 How Entities Connect: The Edge Model\nEdges use a triple structure inspired by RDF:\n\nSubject (s): The source entity’s row_id\nPredicate (p): The relationship type\nObject (o): Array of target entity row_ids\n\nThis allows representing both simple (1:1) and complex (1:many) relationships efficiently.\n\n\nCode\n// Visualize common relationship patterns\nrelationshipPatterns = {\n    const query = `\n        SELECT\n            p as relationship,\n            COUNT(*) as usage_count,\n            COUNT(DISTINCT s) as unique_subjects\n        FROM nodes\n        WHERE otype = '_edge_'\n          AND p IS NOT NULL\n        GROUP BY p\n        ORDER BY usage_count DESC\n        LIMIT 15\n    `;\n    const data = await loadData(query, [], \"loading_relationships\");\n    return data;\n}\n\n\n\n\n\n\n\n\nLoading relationship patterns…\n\n\n\nCode\nviewof relationshipTable = Inputs.table(relationshipPatterns, {\n    header: {\n        relationship: \"Relationship Type\",\n        usage_count: \"Total Uses\",\n        unique_subjects: \"Unique Subjects\"\n    },\n    format: {\n        usage_count: d =&gt; d.toLocaleString(),\n        unique_subjects: d =&gt; d.toLocaleString()\n    }\n})"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#critical-discovery-correct-relationship-paths",
    "href": "tutorials/oc_parquet_enhanced.html#critical-discovery-correct-relationship-paths",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "4 🚨 Critical Discovery: Correct Relationship Paths",
    "text": "4 🚨 Critical Discovery: Correct Relationship Paths\nBefore you query this data, understand this key insight:\n❌ Common Mistake: Assuming direct Sample → Location relationships ✅ Reality: All location queries require multi-hop traversal through SamplingEvent\n\n4.1 The Correct Traversals Discovered (Using Typed Edges)\nDirect Location (via EVENT_SAMPLE_LOCATION)\nMaterialSampleRecord → MSR_PRODUCED_BY → SamplingEvent → EVENT_SAMPLE_LOCATION → GeospatialCoordLocation\nSite-Mediated Location (via EVENT_SAMPLING_SITE → SITE_LOCATION)\nMaterialSampleRecord → MSR_PRODUCED_BY → SamplingEvent → EVENT_SAMPLING_SITE → SamplingSite → SITE_LOCATION → GeospatialCoordLocation\nThis discovery unlocked 1,096,274 samples that were previously inaccessible due to incorrect query patterns!"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#working-with-the-graph-query-patterns",
    "href": "tutorials/oc_parquet_enhanced.html#working-with-the-graph-query-patterns",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "5 Working with the Graph: Query Patterns",
    "text": "5 Working with the Graph: Query Patterns\n\n5.1 Finding Samples with Locations (CORRECTED)\nThe most common need is connecting samples to their geographic coordinates. This requires traversing the graph through edges:\n\n\nCode\n// Example: Get samples with direct location assignments (CORRECTED)\n// Path: Sample -&gt; produced_by -&gt; SamplingEvent -&gt; sample_location -&gt; GeospatialCoordLocation\nsampleLocationExample = {\n    const query = `\n        WITH sample_locations AS (\n            SELECT\n                s.pid as sample_id,\n                s.label as sample_label,\n                g.latitude,\n                g.longitude,\n                'direct_event_location' as location_relationship\n            FROM nodes s\n            JOIN nodes e1 ON s.row_id = e1.s AND e1.p = 'produced_by'\n            JOIN nodes event ON e1.o[1] = event.row_id\n            JOIN nodes e2 ON event.row_id = e2.s AND e2.p = 'sample_location'\n            JOIN nodes g ON e2.o[1] = g.row_id\n            WHERE s.otype = 'MaterialSampleRecord'\n              AND event.otype = 'SamplingEvent'\n              AND g.otype = 'GeospatialCoordLocation'\n              AND g.latitude IS NOT NULL\n            LIMIT 5\n        )\n        SELECT * FROM sample_locations\n    `;\n    const data = await loadData(query, [], \"loading_sample_loc_example\");\n    return data;\n}\n\n\n\n\n\n\n\n\nLoading example…\n\n\n\nCode\nviewof sampleLocationTable = Inputs.table(sampleLocationExample, {\n    layout: \"auto\"\n})\n\n\n\n\n\n\n\n\n\n5.2 ⚠️ Why Previous Queries Failed\nMany existing examples tried this incorrect pattern:\n-- ❌ BROKEN: This relationship doesn't exist!\nFROM MaterialSampleRecord s\nJOIN edge e ON s.row_id = e.s AND e.p = 'sample_location'\nJOIN GeospatialCoordLocation g ON e.o[1] = g.row_id\nResult: 0 samples found\nThe correct pattern requires going through SamplingEvent:\n-- ✅ CORRECT: Multi-hop traversal\nFROM MaterialSampleRecord s\nJOIN edge e1 ON s.row_id = e1.s AND e1.p = 'produced_by'\nJOIN SamplingEvent event ON e1.o[1] = event.row_id\nJOIN edge e2 ON event.row_id = e2.s AND e2.p = 'sample_location'\nJOIN GeospatialCoordLocation g ON e2.o[1] = g.row_id\nResult: 1,096,274 samples found!\n\n\n5.3 Multi-Hop Traversal: Sample → Event → Site → Location\nMany samples don’t have direct coordinates but are linked through their collection event and site:\n\n\nCode\n// Trace the full chain from sample to site location\nsiteChainExample = {\n    const query = `\n        SELECT\n            samp.pid as sample_id,\n            event.pid as event_id,\n            site.label as site_name,\n            loc.latitude,\n            loc.longitude\n        FROM nodes samp\n        JOIN nodes e1 ON samp.row_id = e1.s AND e1.p = 'produced_by'\n        JOIN nodes event ON e1.o[1] = event.row_id\n        JOIN nodes e2 ON event.row_id = e2.s AND e2.p = 'sampling_site'\n        JOIN nodes site ON e2.o[1] = site.row_id\n        JOIN nodes e3 ON site.row_id = e3.s AND e3.p = 'site_location'\n        JOIN nodes loc ON e3.o[1] = loc.row_id\n        WHERE samp.otype = 'MaterialSampleRecord'\n          AND event.otype = 'SamplingEvent'\n          AND site.otype = 'SamplingSite'\n          AND loc.otype = 'GeospatialCoordLocation'\n        LIMIT 5\n    `;\n    const data = await loadData(query, [], \"loading_chain_example\");\n    return data;\n}\n\n\n\n\n\n\n\n\nLoading traversal example…\n\n\n\nCode\nviewof siteChainTable = Inputs.table(siteChainExample, {\n    layout: \"auto\",\n    width: {\n        sample_id: 150,\n        event_id: 150,\n        site_name: 200\n    }\n})"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#site-analysis",
    "href": "tutorials/oc_parquet_enhanced.html#site-analysis",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "6 Site Analysis",
    "text": "6 Site Analysis\n\n6.1 Top Archaeological Sites by Sample Count\n\n\nCode\ntopSites = {\n    const query = `\n        WITH site_samples AS (\n            SELECT\n                site.label as site_name,\n                site.pid as site_id,\n                COUNT(DISTINCT samp.row_id) as sample_count\n            FROM nodes samp\n            JOIN nodes e1 ON samp.row_id = e1.s AND e1.p = 'produced_by'\n            JOIN nodes event ON e1.o[1] = event.row_id\n            JOIN nodes e2 ON event.row_id = e2.s AND e2.p = 'sampling_site'\n            JOIN nodes site ON e2.o[1] = site.row_id\n            WHERE samp.otype = 'MaterialSampleRecord'\n              AND event.otype = 'SamplingEvent'\n              AND site.otype = 'SamplingSite'\n            GROUP BY site.label, site.pid\n        )\n        SELECT * FROM site_samples\n        ORDER BY sample_count DESC\n        LIMIT 20\n    `;\n    const data = await loadData(query, [], \"loading_top_sites\");\n    return data;\n}\n\n\n\n\n\n\n\n\nLoading site statistics…\n\n\n\nCode\nviewof topSitesTable = Inputs.table(topSites, {\n    header: {\n        site_name: \"Site Name\",\n        site_id: \"Site ID\",\n        sample_count: \"Sample Count\"\n    },\n    format: {\n        sample_count: d =&gt; d.toLocaleString()\n    }\n})"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#material-analysis",
    "href": "tutorials/oc_parquet_enhanced.html#material-analysis",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "7 Material Analysis",
    "text": "7 Material Analysis\n\n7.1 Material Type Distribution\nUnderstanding what types of materials are found across the dataset:\n\n\nCode\nmaterialTypes = {\n    const query = `\n        SELECT\n            mat.label as material_type,\n            mat.name as category,\n            COUNT(DISTINCT samp.row_id) as sample_count\n        FROM nodes samp\n        JOIN nodes e ON samp.row_id = e.s AND e.p = 'has_material_category'\n        JOIN nodes mat ON e.o[1] = mat.row_id\n        WHERE samp.otype = 'MaterialSampleRecord'\n          AND e.otype = '_edge_'\n          AND mat.otype = 'IdentifiedConcept'\n        GROUP BY mat.label, mat.name\n        ORDER BY sample_count DESC\n        LIMIT 30\n    `;\n    const data = await loadData(query, [], \"loading_materials\");\n    return data;\n}\n\n\n\n\n\n\n\n\nAnalyzing materials…\n\n\n\nCode\nviewof materialTable = Inputs.table(materialTypes, {\n    header: {\n        material_type: \"Material Type\",\n        category: \"Category\",\n        sample_count: \"Sample Count\"\n    },\n    format: {\n        sample_count: d =&gt; d.toLocaleString()\n    }\n})"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#spatial-distribution",
    "href": "tutorials/oc_parquet_enhanced.html#spatial-distribution",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "8 Spatial Distribution",
    "text": "8 Spatial Distribution\n\n8.1 Geographic Coverage\n\n\nCode\nspatialStats = {\n    const query = `\n        WITH coord_stats AS (\n            SELECT\n                MIN(latitude) as min_lat,\n                MAX(latitude) as max_lat,\n                MIN(longitude) as min_lon,\n                MAX(longitude) as max_lon,\n                AVG(latitude) as avg_lat,\n                AVG(longitude) as avg_lon,\n                COUNT(*) as total_locations,\n                COUNT(CASE WHEN obfuscated THEN 1 END) as obfuscated_count\n            FROM nodes\n            WHERE otype = 'GeospatialCoordLocation'\n              AND latitude IS NOT NULL\n              AND longitude IS NOT NULL\n        )\n        SELECT * FROM coord_stats\n    `;\n    const data = await loadData(query, [], \"loading_spatial\");\n    return data;\n}\n\n\n\n\n\n\n\n\nLoading spatial statistics…\n\n\n\nCode\nviewof spatialDisplay = {\n    const stats = spatialStats[0];\n    return html`&lt;div style=\"padding: 1rem; background: #f0f9ff; border-radius: 8px;\"&gt;\n        &lt;h4 style=\"margin-top: 0;\"&gt;Geographic Coverage&lt;/h4&gt;\n        &lt;p&gt;Total locations: &lt;strong&gt;${stats.total_locations.toLocaleString()}&lt;/strong&gt;&lt;/p&gt;\n        &lt;p&gt;Obfuscated locations: &lt;strong&gt;${stats.obfuscated_count.toLocaleString()}&lt;/strong&gt;\n           (${(stats.obfuscated_count / stats.total_locations * 100).toFixed(1)}%)&lt;/p&gt;\n        &lt;p&gt;Latitude range: &lt;strong&gt;${stats.min_lat.toFixed(2)}° to ${stats.max_lat.toFixed(2)}°&lt;/strong&gt;&lt;/p&gt;\n        &lt;p&gt;Longitude range: &lt;strong&gt;${stats.min_lon.toFixed(2)}° to ${stats.max_lon.toFixed(2)}°&lt;/strong&gt;&lt;/p&gt;\n        &lt;p&gt;Center point: &lt;strong&gt;${stats.avg_lat.toFixed(2)}°, ${stats.avg_lon.toFixed(2)}°&lt;/strong&gt;&lt;/p&gt;\n    &lt;/div&gt;`;\n}\n\n\n\n\n\n\n\n\n\n8.2 Handling Sensitive Location Data\nArchaeological sites often require location protection:\n\n\nCode\nobfuscationStats = {\n    const query = `\n        SELECT\n            obfuscated,\n            COUNT(*) as location_count,\n            AVG(CASE WHEN latitude IS NOT NULL THEN 1 ELSE 0 END) * 100 as pct_with_coords\n        FROM nodes\n        WHERE otype = 'GeospatialCoordLocation'\n        GROUP BY obfuscated\n    `;\n    const data = await loadData(query, [], \"loading_obfusc_stats\");\n    return data;\n}\n\n\n\n\n\n\n\n\nAnalyzing location sensitivity…\n\n\n\nCode\nviewof obfuscationTable = Inputs.table(obfuscationStats, {\n    header: {\n        obfuscated: \"Location Protection\",\n        location_count: \"Count\",\n        pct_with_coords: \"% With Coordinates\"\n    },\n    format: {\n        obfuscated: d =&gt; d ? \"🔒 Protected\" : \"📍 Precise\",\n        location_count: d =&gt; d.toLocaleString(),\n        pct_with_coords: d =&gt; d.toFixed(1) + \"%\"\n    }\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportantData Usage Note\n\n\n\nWhen visualizing archaeological data, always respect location sensitivity flags. Obfuscated coordinates are intentionally imprecise to protect archaeological sites from looting."
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#debugging-methodology-how-we-found-the-correct-paths",
    "href": "tutorials/oc_parquet_enhanced.html#debugging-methodology-how-we-found-the-correct-paths",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "9 🔍 Debugging Methodology: How We Found the Correct Paths",
    "text": "9 🔍 Debugging Methodology: How We Found the Correct Paths\n\n9.1 Step 1: Verify Relationship Existence\n\n\nCode\n// Debug: What relationships actually exist FROM MaterialSampleRecord?\ndebugRelationships = {\n    const query = `\n        SELECT DISTINCT e.p as predicate, COUNT(*) as count\n        FROM nodes s\n        JOIN nodes e ON s.row_id = e.s\n        WHERE s.otype = 'MaterialSampleRecord'\n          AND e.otype = '_edge_'\n        GROUP BY e.p\n        ORDER BY count DESC\n    `;\n    const data = await loadData(query, [], \"loading_debug_rels\");\n    return data;\n}\n\n\n\n\n\n\n\n\nDebugging relationships…\n\n\n\nCode\nviewof debugTable = Inputs.table(debugRelationships, {\n    header: {\n        predicate: \"Relationship Type\",\n        count: \"Usage Count\"\n    },\n    format: {\n        count: d =&gt; d.toLocaleString()\n    }\n})\n\n\n\n\n\n\n\nNotice: No direct sample_location relationship! This confirms why direct queries failed.\n\n\n9.2 Step 2: Trace the Path Through SamplingEvent\n\n\nCode\n// Debug: What relationships exist FROM SamplingEvent?\ndebugEventRelationships = {\n    const query = `\n        SELECT DISTINCT e.p as predicate, COUNT(*) as count\n        FROM nodes s\n        JOIN nodes e ON s.row_id = e.s\n        WHERE s.otype = 'SamplingEvent'\n          AND e.otype = '_edge_'\n        GROUP BY e.p\n        ORDER BY count DESC\n    `;\n    const data = await loadData(query, [], \"loading_debug_events\");\n    return data;\n}\n\n\n\n\n\n\n\n\nDebugging event relationships…\n\n\n\nCode\nviewof debugEventTable = Inputs.table(debugEventRelationships, {\n    header: {\n        predicate: \"Event Relationship\",\n        count: \"Count\"\n    },\n    format: {\n        count: d =&gt; d.toLocaleString()\n    }\n})\n\n\n\n\n\n\n\nKey Discovery: SamplingEvent has both sample_location AND sampling_site relationships!\n\n\n9.3 Step 3: Validate the Complete Chain\n\n\nCode\n// Test: How many samples can we locate using the corrected path?\nlocationValidation = {\n    const query = `\n        WITH validation_stats AS (\n            -- Direct path count\n            SELECT 'Direct Event Location' as path_type, COUNT(*) as sample_count\n            FROM nodes s\n            JOIN nodes e1 ON s.row_id = e1.s AND e1.p = 'produced_by'\n            JOIN nodes event ON e1.o[1] = event.row_id\n            JOIN nodes e2 ON event.row_id = e2.s AND e2.p = 'sample_location'\n            JOIN nodes g ON e2.o[1] = g.row_id\n            WHERE s.otype = 'MaterialSampleRecord'\n              AND event.otype = 'SamplingEvent'\n              AND g.otype = 'GeospatialCoordLocation'\n              AND g.latitude IS NOT NULL\n\n            UNION ALL\n\n            -- Site path count\n            SELECT 'Via Site Location' as path_type, COUNT(*) as sample_count\n            FROM nodes s\n            JOIN nodes e1 ON s.row_id = e1.s AND e1.p = 'produced_by'\n            JOIN nodes event ON e1.o[1] = event.row_id\n            JOIN nodes e2 ON event.row_id = e2.s AND e2.p = 'sampling_site'\n            JOIN nodes site ON e2.o[1] = site.row_id\n            JOIN nodes e3 ON site.row_id = e3.s AND e3.p = 'site_location'\n            JOIN nodes g ON e3.o[1] = g.row_id\n            WHERE s.otype = 'MaterialSampleRecord'\n              AND event.otype = 'SamplingEvent'\n              AND site.otype = 'SamplingSite'\n              AND g.otype = 'GeospatialCoordLocation'\n              AND g.latitude IS NOT NULL\n        )\n        SELECT * FROM validation_stats\n    `;\n    const data = await loadData(query, [], \"loading_validation\");\n    return data;\n}\n\n\n\n\n\n\n\n\nValidating corrected paths…\n\n\n\nCode\nviewof validationTable = Inputs.table(locationValidation, {\n    header: {\n        path_type: \"Query Path\",\n        sample_count: \"Samples Found\"\n    },\n    format: {\n        sample_count: d =&gt; d.toLocaleString()\n    }\n})\n\n\n\n\n\n\n\n🎉 Success! Both paths yield over 1M samples each.\n\n\n9.4 Debugging Lessons Learned\n\nNever assume direct relationships exist - always verify the graph structure first\nTrace step-by-step - build from simple entity counts to complex joins\nTest multiple paths - property graphs often have alternative routes\nValidate results - sanity check your numbers against known entity counts"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#performance-optimization-strategies",
    "href": "tutorials/oc_parquet_enhanced.html#performance-optimization-strategies",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "10 Performance & Optimization Strategies",
    "text": "10 Performance & Optimization Strategies\n\n10.1 Query Performance Guidelines\nWhen working with this 11.6M row dataset:\n\nFilter Early: Always apply otype filters first\n-- Good: Reduces to ~1M rows immediately\nWHERE otype = 'MaterialSampleRecord'\n\n-- Avoid: Scans all 11M rows\nWHERE label LIKE '%pottery%'\nUse Views for Complex Patterns: Pre-compute common joins\nCREATE VIEW samples_with_coords AS\nSELECT ... -- complex join query\nLeverage DuckDB’s Columnar Format: Aggregate before detailed analysis\n\n\n\n10.2 Data Loading Strategies\nFor web applications:\n\n\nCode\n// Progressive loading pattern for large datasets\nprogressiveLoadExample = {\n    // Start with aggregated overview\n    const overview = await db.query(`\n        SELECT\n            ROUND(latitude/10)*10 as lat_bucket,\n            ROUND(longitude/10)*10 as lon_bucket,\n            COUNT(*) as point_count\n        FROM nodes\n        WHERE otype = 'GeospatialCoordLocation'\n          AND latitude IS NOT NULL\n        GROUP BY lat_bucket, lon_bucket\n    `);\n\n    return {\n        strategy: \"Progressive Loading\",\n        initial_points: overview.length,\n        full_dataset: 198433,\n        reduction_factor: Math.round(198433 / overview.length)\n    };\n}\n\n\n\n\n\n\n\n\n\nCode\nviewof loadStrategyDisplay = {\n    const stats = await progressiveLoadExample;\n    return html`&lt;div style=\"padding: 1rem; background: #e0f2fe; border-radius: 8px;\"&gt;\n        &lt;h4 style=\"margin-top: 0;\"&gt;Loading Strategy Impact&lt;/h4&gt;\n        &lt;p&gt;Initial load: &lt;strong&gt;${stats.initial_points.toLocaleString()}&lt;/strong&gt; aggregated points&lt;/p&gt;\n        &lt;p&gt;Full dataset: &lt;strong&gt;${stats.full_dataset.toLocaleString()}&lt;/strong&gt; individual locations&lt;/p&gt;\n        &lt;p&gt;Reduction factor: &lt;strong&gt;${stats.reduction_factor}x&lt;/strong&gt; faster initial load&lt;/p&gt;\n    &lt;/div&gt;`;\n}"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#data-quality-metrics",
    "href": "tutorials/oc_parquet_enhanced.html#data-quality-metrics",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "11 Data Quality Metrics",
    "text": "11 Data Quality Metrics\n\n\nCode\ndataQuality = {\n    const query = `\n        WITH quality_checks AS (\n            SELECT\n                'Total Rows' as metric,\n                COUNT(*) as value\n            FROM nodes\n\n            UNION ALL\n\n            SELECT\n                'Unique PIDs' as metric,\n                COUNT(DISTINCT pid) as value\n            FROM nodes\n\n            UNION ALL\n\n            SELECT\n                'Samples with Direct Location' as metric,\n                COUNT(DISTINCT s.row_id) as value\n            FROM nodes s\n            JOIN nodes e ON s.row_id = e.s AND e.p = 'sample_location'\n            WHERE s.otype = 'MaterialSampleRecord'\n\n            UNION ALL\n\n            SELECT\n                'Samples with Site Location' as metric,\n                COUNT(DISTINCT s.row_id) as value\n            FROM nodes s\n            JOIN nodes e ON s.row_id = e.s AND e.p = 'produced_by'\n            WHERE s.otype = 'MaterialSampleRecord'\n        )\n        SELECT * FROM quality_checks\n    `;\n    const data = await loadData(query, [], \"loading_quality\");\n    return data;\n}\n\n\n\n\n\n\n\n\nChecking data quality…\n\n\n\nCode\nviewof qualityTable = Inputs.table(dataQuality, {\n    header: {\n        metric: \"Quality Metric\",\n        value: \"Count\"\n    },\n    format: {\n        value: d =&gt; d.toLocaleString()\n    }\n})"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#archaeological-data-insights",
    "href": "tutorials/oc_parquet_enhanced.html#archaeological-data-insights",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "12 Archaeological Data Insights",
    "text": "12 Archaeological Data Insights\n\n12.1 Top Archaeological Sites by Sample Count\n\n\nCode\ntopSitesByCount = {\n    const query = `\n        WITH sample_to_site AS (\n            SELECT\n                site.label as site_name,\n                COUNT(DISTINCT samp.row_id) as sample_count\n            FROM nodes samp\n            JOIN nodes e1 ON samp.row_id = e1.s AND e1.p = 'produced_by'\n            JOIN nodes event ON e1.o[1] = event.row_id\n            JOIN nodes e2 ON event.row_id = e2.s AND e2.p = 'sampling_site'\n            JOIN nodes site ON e2.o[1] = site.row_id\n            WHERE samp.otype = 'MaterialSampleRecord'\n              AND event.otype = 'SamplingEvent'\n              AND site.otype = 'SamplingSite'\n            GROUP BY site.label\n        )\n        SELECT * FROM sample_to_site\n        ORDER BY sample_count DESC\n        LIMIT 10\n    `;\n    const data = await loadData(query, [], \"loading_top_sites\");\n    return data;\n}\n\n\n\n\n\n\n\n\nLoading top archaeological sites…\n\n\n\nCode\nviewof topSitesTable = Inputs.table(topSitesByCount, {\n    header: {\n        site_name: \"Archaeological Site\",\n        sample_count: \"Sample Count\"\n    },\n    format: {\n        sample_count: d =&gt; d.toLocaleString()\n    }\n})\n\n\n\n\n\n\n\n\n\n12.2 Material Type Distribution\n\n\nCode\nmaterialDistribution = {\n    const query = `\n        SELECT\n            mat.label as material_type,\n            COUNT(DISTINCT samp.row_id) as sample_count\n        FROM nodes samp\n        JOIN nodes e ON samp.row_id = e.s AND e.p = 'has_material_category'\n        JOIN nodes mat ON e.o[1] = mat.row_id\n        WHERE samp.otype = 'MaterialSampleRecord'\n          AND e.otype = '_edge_'\n          AND mat.otype = 'IdentifiedConcept'\n        GROUP BY mat.label\n        ORDER BY sample_count DESC\n        LIMIT 10\n    `;\n    const data = await loadData(query, [], \"loading_materials\");\n    return data;\n}\n\n\n\n\n\n\n\n\nLoading material types…\n\n\n\nCode\nviewof materialTable = Inputs.table(materialDistribution, {\n    header: {\n        material_type: \"Material Type\",\n        sample_count: \"Sample Count\"\n    },\n    format: {\n        sample_count: d =&gt; d.toLocaleString()\n    }\n})\n\n\n\n\n\n\n\nKey Insights: - Çatalhöyük leads with 145,900+ samples - one of the world’s largest Neolithic sites - Biogenic non-organic materials dominate (bones, shells) reflecting archaeological preservation - Global coverage spans from Arctic (Finnmark) to temperate zones"
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#summary-key-lessons-for-querying-opencontext-parquet",
    "href": "tutorials/oc_parquet_enhanced.html#summary-key-lessons-for-querying-opencontext-parquet",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "13 Summary: Key Lessons for Querying OpenContext Parquet",
    "text": "13 Summary: Key Lessons for Querying OpenContext Parquet\n\n13.1 🎯 Essential Discoveries\n\nCritical Bug Fix: Direct Sample→Location queries don’t work\n\nProblem: Returned 0 results from 1M+ sample dataset\nSolution: Always traverse through SamplingEvent\nImpact: Unlocked access to 1,096,274 located samples\n\nCorrect Relationship Paths:\n✅ Sample → produced_by → SamplingEvent → sample_location → Location\n✅ Sample → produced_by → SamplingEvent → sampling_site → Site → site_location → Location\nProperty Graph Structure:\n\n79% edges, 21% entities in 11.6M rows\nMulti-hop traversal required for meaningful queries\nNo shortcuts exist - respect the graph model\n\n\n\n\n13.2 🔧 Debugging Methodology\n\nVerify relationships exist before building complex queries\nTrace step-by-step from simple counts to complex joins\nTest multiple paths - graphs often have alternative routes\nValidate results against known entity counts\n\n\n\n13.3 ⚡ Performance Guidelines\n\nFilter by otype first - reduces 11M rows to manageable subsets\nUse CTEs for complex multi-hop queries\nAggregate before filtering when possible\nRespect obfuscated coordinates for site protection\n\n\n\n13.4 🏛️ Archaeological Context\n\nMajor sites: Çatalhöyük, Petra, Polis Chrysochous dominate sample counts\nMaterial types: Biogenic non-organic materials most common\nGlobal reach: Arctic to Antarctic coverage with sensitive location protection\nResearch value: 1M+ precisely located specimens for spatial analysis\n\n\n\n13.5 🚀 Advanced Applications\nThis corrected understanding enables: - Spatial clustering analysis of archaeological finds - Temporal pattern recognition through sampling events - Site similarity studies via material type distributions - Collection bias analysis through agent and responsibility networks\nThe key to success: Understand the graph model first, query second. This property graph structure reflects the real-world complexity of archaeological data collection and enables sophisticated analysis when queried correctly."
  },
  {
    "objectID": "tutorials/oc_parquet_enhanced.html#next-steps",
    "href": "tutorials/oc_parquet_enhanced.html#next-steps",
    "title": "OpenContext Parquet Data Analysis - Enhanced Edition",
    "section": "14 Next Steps",
    "text": "14 Next Steps\nReady to analyze this data? Remember: 1. Start with entity relationship exploration 2. Build queries incrementally 3. Validate results at each step 4. Respect archaeological site sensitivities\nHappy querying! 🏺"
  },
  {
    "objectID": "tutorials/parquet_cesium_wide.html",
    "href": "tutorials/parquet_cesium_wide.html",
    "title": "Using Cesium for display of remote parquet (Wide Format).",
    "section": "",
    "text": "This page renders points from an iSamples wide-format parquet file on Cesium using point primitives.\nCesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwNzk3NjkyMy1iNGI1LTRkN2UtODRiMy04OTYwYWE0N2M3ZTkiLCJpZCI6Njk1MTcsImlhdCI6MTYzMzU0MTQ3N30.e70dpNzOCDRLDGxRguQCC-tRzGzA-23Xgno5lNgCeB4';\nviewof parquet_path = Inputs.text({\n  label:\"Source (Wide Format)\",\n  value:\"https://storage.googleapis.com/opencontext-parquet/oc_isamples_pqg_wide.parquet\",\n  placeholder: \"URL or file:///path/to/file.parquet\",\n  width:\"100%\",\n  submit:true\n});\nviewof searchGeoPid = Inputs.text({\n  label:\"Jump to Geocode\",\n  placeholder: \"Paste geocode PID (e.g., geoloc_04d6e816218b1a8798fa90b3d1d43bf4c043a57f)\",\n  width:\"100%\",\n  submit:true\n});\nviewof classifyTrigger = {\n  let count = 0;\n  const button = html`&lt;button\n    style=\"padding: 8px 16px; margin: 10px 0; background: #2E86AB; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;\"&gt;\n    🎨 Color-code by type (sample/site/both)\n  &lt;/button&gt;`;\n  button.onclick = () =&gt; {\n    count++;\n    button.value = count;\n    button.dispatchEvent(new CustomEvent(\"input\"));\n  };\n  button.value = count;\n  return button;\n}\n\n// Alias for handler compatibility\nclassifyDots = classifyTrigger &gt; 0 ? classifyTrigger : null\nCode\ndb = {\n  const instance = await DuckDBClient.of();\n  await instance.query(`create view nodes as select * from read_parquet('${parquet_path}')`)\n  return instance;\n}\n\n\nasync function loadData(query, params = [], waiting_id = null, key = \"default\") {\n    // latest-only guard per key\n    loadData._latest = loadData._latest || new Map();\n    const requestToken = Symbol();\n    loadData._latest.set(key, requestToken);\n\n    // Get loading indicator\n    const waiter = waiting_id ? document.getElementById(waiting_id) : null;\n    if (waiter) waiter.hidden = false;\n\n    try {\n        // Run the (slow) query\n        const _results = await db.query(query, params);\n        // Ignore stale responses\n        if (loadData._latest.get(key) !== requestToken) return null;\n        return _results;\n    } catch (error) {\n        if (waiter && loadData._latest.get(key) === requestToken) {\n            waiter.innerHTML = `&lt;pre&gt;${error}&lt;/pre&gt;`;\n        }\n        return null;\n    } finally {\n        // Hide the waiter (if there is one) only if latest\n        if (waiter && loadData._latest.get(key) === requestToken) {\n            waiter.hidden = true;\n        }\n    }\n}\n\nlocations = {\n    // Performance telemetry\n    performance.mark('locations-start');\n\n    // Get loading indicator element for progress updates\n    const loadingDiv = document.getElementById('loading_1');\n    if (loadingDiv) {\n        loadingDiv.hidden = false;\n        loadingDiv.innerHTML = 'Loading geocodes...';\n    }\n\n    // Fast query: just get all distinct geocodes (no classification!)\n    const query = `\n        SELECT DISTINCT\n            pid,\n            latitude,\n            longitude\n        FROM nodes\n        WHERE otype = 'GeospatialCoordLocation'\n    `;\n\n    performance.mark('query-start');\n    const data = await loadData(query, [], \"loading_1\", \"locations\");\n    performance.mark('query-end');\n    performance.measure('locations-query', 'query-start', 'query-end');\n    const queryTime = performance.getEntriesByName('locations-query')[0].duration;\n    console.log(`Query executed in ${queryTime.toFixed(0)}ms - retrieved ${data.length} locations`);\n\n    // Clear the existing PointPrimitiveCollection\n    content.points.removeAll();\n\n    // Single color for all points (blue)\n    const defaultColor = Cesium.Color.fromCssColorString('#2E86AB');\n    const defaultSize = 4;\n\n    // Render points in chunks to keep UI responsive\n    const CHUNK_SIZE = 500;\n    const scalar = new Cesium.NearFarScalar(1.5e2, 2, 8.0e6, 0.2);\n\n    performance.mark('render-start');\n    for (let i = 0; i &lt; data.length; i += CHUNK_SIZE) {\n        const chunk = data.slice(i, i + CHUNK_SIZE);\n        const endIdx = Math.min(i + CHUNK_SIZE, data.length);\n\n        // Update progress indicator\n        if (loadingDiv) {\n            const pct = Math.round((endIdx / data.length) * 100);\n            loadingDiv.innerHTML = `Rendering geocodes... ${endIdx.toLocaleString()}/${data.length.toLocaleString()} (${pct}%)`;\n        }\n\n        // Add points for this chunk\n        for (const row of chunk) {\n            content.points.add({\n                id: row.pid,\n                position: Cesium.Cartesian3.fromDegrees(\n                    row.longitude,  //longitude\n                    row.latitude,   //latitude\n                    0               //elevation, m\n                ),\n                pixelSize: defaultSize,\n                color: defaultColor,\n                scaleByDistance: scalar,\n            });\n        }\n\n        // Yield to browser between chunks to keep UI responsive\n        if (i + CHUNK_SIZE &lt; data.length) {\n            await new Promise(resolve =&gt; setTimeout(resolve, 0));\n        }\n    }\n    performance.mark('render-end');\n    performance.measure('locations-render', 'render-start', 'render-end');\n    const renderTime = performance.getEntriesByName('locations-render')[0].duration;\n\n    // Hide loading indicator\n    if (loadingDiv) {\n        loadingDiv.hidden = true;\n    }\n\n    performance.mark('locations-end');\n    performance.measure('locations-total', 'locations-start', 'locations-end');\n    const totalTime = performance.getEntriesByName('locations-total')[0].duration;\n\n    console.log(`Rendering completed in ${renderTime.toFixed(0)}ms`);\n    console.log(`Total time (query + render): ${totalTime.toFixed(0)}ms`);\n\n    content.enableTracking();\n    return data;\n}\n\n\nfunction createShowPrimitive(viewer) {\n    return function(movement) {\n        // Get the point at the mouse end position\n        const selectPoint = viewer.viewer.scene.pick(movement.endPosition);\n\n        // Clear the current selection, if there is one and it is different to the selectPoint\n        if (viewer.currentSelection !== null) {\n            //console.log(`selected.p ${viewer.currentSelection}`)\n            if (Cesium.defined(selectPoint) && selectPoint !== viewer.currentSelection) {\n                console.log(`selected.p 2 ${viewer.currentSelection}`)\n                viewer.currentSelection.primitive.pixelSize = 4;\n                viewer.currentSelection.primitive.outlineColor = Cesium.Color.TRANSPARENT;\n                viewer.currentSelection.outlineWidth = 0;\n                viewer.currentSelection = null;\n            }\n        }\n\n        // If selectPoint is valid and no currently selected point\n        if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n            //console.log(`showPrimitiveId ${selectPoint.id}`);\n            //const carto = Cesium.Cartographic.fromCartesian(selectPoint.primitive.position)\n            viewer.pointLabel.position = selectPoint.primitive.position;\n            viewer.pointLabel.label.show = true;\n            //viewer.pointLabel.label.text = `id:${selectPoint.id}, ${carto}`;\n            viewer.pointLabel.label.text = `${selectPoint.id}`;\n            selectPoint.primitive.pixelSize = 20;\n            selectPoint.primitive.outlineColor = Cesium.Color.YELLOW;\n            selectPoint.primitive.outlineWidth = 3;\n            viewer.currentSelection = selectPoint;\n        } else {\n            viewer.pointLabel.label.show = false;\n        }\n    }\n}\n\nclass CView {\n    constructor(target) {\n        this.viewer = new Cesium.Viewer(\n            target, {\n                timeline: false,\n                animation: false,\n                baseLayerPicker: false,\n                fullscreenElement: target,\n                terrain: Cesium.Terrain.fromWorldTerrain()\n            });\n        this.currentSelection = null;\n        this.point_size = 1;\n        this.n_points = 0;\n        // https://cesium.com/learn/cesiumjs/ref-doc/PointPrimitiveCollection.html\n        this.points = new Cesium.PointPrimitiveCollection();\n        this.viewer.scene.primitives.add(this.points);\n\n        this.pointLabel = this.viewer.entities.add({\n            label: {\n            show: false,\n            showBackground: true,\n            font: \"14px monospace\",\n            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,\n            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,\n            pixelOffset: new Cesium.Cartesian2(15, 0),\n            // this attribute will prevent this entity clipped by the terrain\n            disableDepthTestDistance: Number.POSITIVE_INFINITY,\n            text:\"\",\n            },\n        });\n\n        this.pickHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        // Can also do this rather than wait for the points to be generated\n        //this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n\n        this.selectHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        this.selectHandler.setInputAction((e) =&gt; {\n            const selectPoint = this.viewer.scene.pick(e.position);\n            if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n                mutable clickedPointId = selectPoint.id;\n            }\n        },Cesium.ScreenSpaceEventType.LEFT_CLICK);\n\n    }\n\n    enableTracking() {\n        this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n    }\n}\n\ncontent = new CView(\"cesiumContainer\");\n\nasync function getGeoRecord(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return \"unset\";\n    }\n    const q = `SELECT row_id, pid, otype, latitude, longitude FROM nodes WHERE otype='GeospatialCoordLocation' AND pid=?`;\n    const rows = await loadData(q, [pid], \"loading_geo\", \"geo\");\n    return rows && rows.length ? rows[0] : null;\n}\n\n// WIDE FORMAT: Direct Location (p__sample_location / EVENT_SAMPLE_LOCATION)\n// Uses p__sample_location column instead of edge row JOINs\nasync function get_samples_1(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return [];\n    }\n    // Direct Location (EVENT_SAMPLE_LOCATION) - WIDE FORMAT version\n    // Uses p__* columns instead of edge rows\n    const q = `\n        SELECT\n            geo.latitude,\n            geo.longitude,\n            site.label AS sample_site_label,\n            site.pid AS sample_site_pid,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail,\n            'direct_event_location' as location_path\n        FROM nodes AS geo\n        -- Wide format: SamplingEvent has p__sample_location column with geo row_ids\n        JOIN nodes AS se ON (\n            se.otype = 'SamplingEvent'\n            AND list_contains(se.p__sample_location, geo.row_id)\n        )\n        -- Wide format: SamplingEvent has p__sampling_site column with site row_ids\n        JOIN nodes AS site ON (\n            site.otype = 'SamplingSite'\n            AND list_contains(se.p__sampling_site, site.row_id)\n        )\n        -- Wide format: MaterialSampleRecord has p__produced_by column with event row_ids\n        JOIN nodes AS samp ON (\n            samp.otype = 'MaterialSampleRecord'\n            AND list_contains(samp.p__produced_by, se.row_id)\n        )\n        WHERE geo.pid = ?\n          AND geo.otype = 'GeospatialCoordLocation'\n        ORDER BY has_thumbnail DESC\n    `;\n    performance.mark('samples1-start');\n    const result = await loadData(q, [pid], \"loading_s1\", \"samples_1\");\n    performance.mark('samples1-end');\n    performance.measure('samples1-query', 'samples1-start', 'samples1-end');\n    const queryTime = performance.getEntriesByName('samples1-query')[0].duration;\n    console.log(`Direct location query (wide) executed in ${queryTime.toFixed(0)}ms - retrieved ${result?.length || 0} samples`);\n    return result ?? [];\n}\n\n// WIDE FORMAT: Site-Mediated Location (p__sampling_site → p__site_location)\n// Uses p__site_location and p__sampling_site columns\nasync function get_samples_2(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return [];\n    }\n    // Site-Mediated Location (SITE_LOCATION) - WIDE FORMAT version\n    const q = `\n        SELECT\n            geo.latitude,\n            geo.longitude,\n            site.label AS sample_site_label,\n            site.pid AS sample_site_pid,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail,\n            'via_site_location' as location_path\n        FROM nodes AS geo\n        -- Wide format: SamplingSite has p__site_location column with geo row_ids\n        JOIN nodes AS site ON (\n            site.otype = 'SamplingSite'\n            AND list_contains(site.p__site_location, geo.row_id)\n        )\n        -- Wide format: SamplingEvent has p__sampling_site column with site row_ids\n        JOIN nodes AS se ON (\n            se.otype = 'SamplingEvent'\n            AND list_contains(se.p__sampling_site, site.row_id)\n        )\n        -- Wide format: MaterialSampleRecord has p__produced_by column with event row_ids\n        JOIN nodes AS samp ON (\n            samp.otype = 'MaterialSampleRecord'\n            AND list_contains(samp.p__produced_by, se.row_id)\n        )\n        WHERE geo.pid = ?\n          AND geo.otype = 'GeospatialCoordLocation'\n        ORDER BY has_thumbnail DESC\n    `;\n    performance.mark('samples2-start');\n    const result = await loadData(q, [pid], \"loading_s2\", \"samples_2\");\n    performance.mark('samples2-end');\n    performance.measure('samples2-query', 'samples2-start', 'samples2-end');\n    const queryTime = performance.getEntriesByName('samples2-query')[0].duration;\n    console.log(`Site-mediated location query (wide) executed in ${queryTime.toFixed(0)}ms - retrieved ${result?.length || 0} samples`);\n    return result ?? [];\n}\n\n// WIDE FORMAT: Eric Kansa's authoritative query (p__sample_location + p__sampling_site)\n// This is the wide format equivalent of get_samples_at_geo_cord_location_via_sample_event\nasync function get_samples_at_geo_cord_location_via_sample_event(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return [];\n    }\n    // Eric Kansa's authoritative query - WIDE FORMAT version\n    // Source pattern: https://github.com/ekansa/open-context-py\n    const q = `\n        SELECT\n            geo.latitude,\n            geo.longitude,\n            site.label AS sample_site_label,\n            site.pid AS sample_site_pid,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail\n        FROM nodes AS geo\n        -- Wide format: SamplingEvent.p__sample_location contains geo row_ids\n        JOIN nodes AS se ON (\n            se.otype = 'SamplingEvent'\n            AND list_contains(se.p__sample_location, geo.row_id)\n        )\n        -- Wide format: SamplingEvent.p__sampling_site contains site row_ids\n        JOIN nodes AS site ON (\n            site.otype = 'SamplingSite'\n            AND list_contains(se.p__sampling_site, site.row_id)\n        )\n        -- Wide format: MaterialSampleRecord.p__produced_by contains event row_ids\n        JOIN nodes AS samp ON (\n            samp.otype = 'MaterialSampleRecord'\n            AND list_contains(samp.p__produced_by, se.row_id)\n        )\n        WHERE geo.pid = ?\n          AND geo.otype = 'GeospatialCoordLocation'\n        ORDER BY has_thumbnail DESC\n    `;\n    performance.mark('eric-query-start');\n    const result = await loadData(q, [pid], \"loading_combined\", \"samples_combined\");\n    performance.mark('eric-query-end');\n    performance.measure('eric-query', 'eric-query-start', 'eric-query-end');\n    const queryTime = performance.getEntriesByName('eric-query')[0].duration;\n    console.log(`Eric's query (wide) executed in ${queryTime.toFixed(0)}ms - retrieved ${result?.length || 0} samples`);\n    return result ?? [];\n}\n\n// WIDE FORMAT: Get full sample data via sample PID\nasync function get_sample_data_via_sample_pid(sample_pid) {\n    if (sample_pid === null || sample_pid === \"\" || sample_pid === \"unset\") {\n        return null;\n    }\n    // Wide format: Uses p__produced_by, p__sample_location, p__sampling_site columns\n    const q = `\n        SELECT\n            samp.row_id,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail,\n            geo.latitude,\n            geo.longitude,\n            site.label AS sample_site_label,\n            site.pid AS sample_site_pid\n        FROM nodes AS samp\n        -- Wide format: use p__produced_by column\n        JOIN nodes AS se ON (\n            se.otype = 'SamplingEvent'\n            AND list_contains(samp.p__produced_by, se.row_id)\n        )\n        -- Wide format: use p__sample_location column\n        JOIN nodes AS geo ON (\n            geo.otype = 'GeospatialCoordLocation'\n            AND list_contains(se.p__sample_location, geo.row_id)\n        )\n        -- Wide format: use p__sampling_site column\n        JOIN nodes AS site ON (\n            site.otype = 'SamplingSite'\n            AND list_contains(se.p__sampling_site, site.row_id)\n        )\n        WHERE samp.pid = ?\n          AND samp.otype = 'MaterialSampleRecord'\n    `;\n    const result = await loadData(q, [sample_pid], \"loading_sample_data\", \"sample_data\");\n    return result && result.length ? result[0] : null;\n}\n\n// WIDE FORMAT: Get agent info (who collected/registered)\nasync function get_sample_data_agents_sample_pid(sample_pid) {\n    if (sample_pid === null || sample_pid === \"\" || sample_pid === \"unset\") {\n        return [];\n    }\n    // Wide format: Uses p__produced_by and p__responsibility/p__registrant columns\n    const q = `\n        WITH event_agents AS (\n            SELECT\n                samp.pid AS sample_pid,\n                samp.label AS sample_label,\n                samp.description AS sample_description,\n                samp.thumbnail_url AS sample_thumbnail_url,\n                samp.thumbnail_url IS NOT NULL as has_thumbnail,\n                'responsibility' AS predicate,\n                unnest(se.p__responsibility) AS agent_row_id\n            FROM nodes AS samp\n            JOIN nodes AS se ON (\n                se.otype = 'SamplingEvent'\n                AND list_contains(samp.p__produced_by, se.row_id)\n            )\n            WHERE samp.pid = ? AND samp.otype = 'MaterialSampleRecord'\n\n            UNION ALL\n\n            SELECT\n                samp.pid AS sample_pid,\n                samp.label AS sample_label,\n                samp.description AS sample_description,\n                samp.thumbnail_url AS sample_thumbnail_url,\n                samp.thumbnail_url IS NOT NULL as has_thumbnail,\n                'registrant' AS predicate,\n                unnest(samp.p__registrant) AS agent_row_id\n            FROM nodes AS samp\n            WHERE samp.pid = ? AND samp.otype = 'MaterialSampleRecord'\n        )\n        SELECT\n            ea.sample_pid,\n            ea.sample_label,\n            ea.sample_description,\n            ea.sample_thumbnail_url,\n            ea.has_thumbnail,\n            ea.predicate,\n            agent.pid AS agent_pid,\n            agent.name AS agent_name,\n            agent.alternate_identifiers AS agent_alternate_identifiers\n        FROM event_agents ea\n        JOIN nodes AS agent ON (\n            agent.row_id = ea.agent_row_id\n            AND agent.otype = 'Agent'\n        )\n    `;\n    const result = await loadData(q, [sample_pid, sample_pid], \"loading_agents\", \"agents\");\n    return result ?? [];\n}\n\n// WIDE FORMAT: Get classification keywords and types\nasync function get_sample_types_and_keywords_via_sample_pid(sample_pid) {\n    if (sample_pid === null || sample_pid === \"\" || sample_pid === \"unset\") {\n        return [];\n    }\n    // Wide format: Sample has p__keywords, p__has_sample_object_type, p__has_material_category columns\n    const q = `\n        WITH sample_concepts AS (\n            SELECT\n                samp.pid AS sample_pid,\n                samp.label AS sample_label,\n                'keywords' AS predicate,\n                unnest(samp.p__keywords) AS concept_row_id\n            FROM nodes AS samp\n            WHERE samp.pid = ? AND samp.otype = 'MaterialSampleRecord'\n\n            UNION ALL\n\n            SELECT\n                samp.pid AS sample_pid,\n                samp.label AS sample_label,\n                'has_sample_object_type' AS predicate,\n                unnest(samp.p__has_sample_object_type) AS concept_row_id\n            FROM nodes AS samp\n            WHERE samp.pid = ? AND samp.otype = 'MaterialSampleRecord'\n\n            UNION ALL\n\n            SELECT\n                samp.pid AS sample_pid,\n                samp.label AS sample_label,\n                'has_material_category' AS predicate,\n                unnest(samp.p__has_material_category) AS concept_row_id\n            FROM nodes AS samp\n            WHERE samp.pid = ? AND samp.otype = 'MaterialSampleRecord'\n        )\n        SELECT\n            sc.sample_pid,\n            sc.sample_label,\n            sc.predicate,\n            kw.pid AS keyword_pid,\n            kw.label AS keyword\n        FROM sample_concepts sc\n        JOIN nodes AS kw ON (\n            kw.row_id = sc.concept_row_id\n            AND kw.otype = 'IdentifiedConcept'\n        )\n    `;\n    const result = await loadData(q, [sample_pid, sample_pid, sample_pid], \"loading_keywords\", \"keywords\");\n    return result ?? [];\n}\n\nasync function locationUsedBy(rowid){\n    if (rowid === undefined || rowid === null) {\n        return [];\n    }\n    // Wide format: Check which entities reference this location via p__* columns\n    const q = `\n        SELECT pid, otype FROM nodes\n        WHERE list_contains(p__sample_location, ?)\n           OR list_contains(p__site_location, ?)\n    `;\n    return db.query(q, [rowid, rowid]);\n}\n\nmutable clickedPointId = \"unset\";\n// Loading flags to control UI clearing while fetching\nmutable geoLoading = false;\nmutable s1Loading = false;\nmutable s2Loading = false;\nmutable combinedLoading = false;\n\n// Precompute selection-driven data with loading flags\nselectedGeoRecord = {\n    mutable geoLoading = true;\n    try {\n        return await getGeoRecord(clickedPointId);\n    } finally {\n        mutable geoLoading = false;\n    }\n}\n\nselectedSamples1 = {\n    mutable s1Loading = true;\n    try {\n        return await get_samples_1(clickedPointId);\n    } finally {\n        mutable s1Loading = false;\n    }\n}\n\nselectedSamples2 = {\n    mutable s2Loading = true;\n    try {\n        return await get_samples_2(clickedPointId);\n    } finally {\n        mutable s2Loading = false;\n    }\n}\n\nselectedSamplesCombined = {\n    mutable combinedLoading = true;\n    try {\n        return await get_samples_at_geo_cord_location_via_sample_event(clickedPointId);\n    } finally {\n        mutable combinedLoading = false;\n    }\n}\n\nmd`Retrieved ${pointdata.length} locations from ${parquet_path}.`;\n// Center initial Cesium view on PKAP Survey Area and also set Home to PKAP!\n{\n    const viewer = content.viewer;\n    // PKAP Survey Area near Cyprus\n    // Source: https://opencontext.org/subjects/48fd434c-f6d3...\n    const pkapLat = 34.987406;\n    const pkapLon = 33.708047;\n    const delta = 0.3; // degrees padding around point\n    const pkapRect = Cesium.Rectangle.fromDegrees(\n        pkapLon - delta, // west (lon)\n        pkapLat - delta, // south (lat)\n        pkapLon + delta, // east (lon)\n        pkapLat + delta  // north (lat)\n    );\n\n    // Make the Home button go to PKAP as well\n    Cesium.Camera.DEFAULT_VIEW_RECTANGLE = pkapRect;\n    Cesium.Camera.DEFAULT_VIEW_FACTOR = 0.5;\n\n    // Apply camera after the first render to avoid resize/tab visibility issues\n    const once = () =&gt; {\n        viewer.camera.setView({ destination: pkapRect });\n        viewer.scene.postRender.removeEventListener(once);\n    };\n    viewer.scene.postRender.addEventListener(once);\n}\n// Handle geocode search: fly to location and trigger queries\n{\n    if (searchGeoPid && searchGeoPid.trim() !== \"\") {\n        const pid = searchGeoPid.trim();\n\n        // Look up the geocode in the database\n        const q = `SELECT pid, latitude, longitude FROM nodes WHERE otype='GeospatialCoordLocation' AND pid=?`;\n        const result = await db.query(q, [pid]);\n\n        if (result && result.length &gt; 0) {\n            const geo = result[0];\n            const viewer = content.viewer;\n\n            // Fly camera to the location\n            const position = Cesium.Cartesian3.fromDegrees(\n                geo.longitude,\n                geo.latitude,\n                15000  // 15km altitude for good view\n            );\n\n            viewer.camera.flyTo({\n                destination: position,\n                duration: 2.0,  // 2 second flight\n                complete: () =&gt; {\n                    // After camera arrives, trigger the click to load data\n                    mutable clickedPointId = pid;\n                }\n            });\n        } else {\n            // Geocode not found - could display error to user\n            console.warn(`Geocode not found: ${pid}`);\n        }\n    }\n}\n// Handle optional classification button: recolor dots by type\n// WIDE FORMAT: Uses p__sample_location and p__site_location columns directly\n{\n    if (classifyDots !== null) {\n        console.log(\"Classifying dots by type (wide format)...\");\n        performance.mark('classify-start');\n\n        try {\n            // Wide format classification query - uses p__* columns directly\n            const query = `\n                WITH geo_classification AS (\n                    SELECT\n                        geo.pid,\n                        MAX(CASE WHEN se.row_id IS NOT NULL THEN 1 ELSE 0 END) as is_sample_location,\n                        MAX(CASE WHEN site.row_id IS NOT NULL THEN 1 ELSE 0 END) as is_site_location\n                    FROM nodes geo\n                    LEFT JOIN nodes se ON (\n                        se.otype = 'SamplingEvent'\n                        AND list_contains(se.p__sample_location, geo.row_id)\n                    )\n                    LEFT JOIN nodes site ON (\n                        site.otype = 'SamplingSite'\n                        AND list_contains(site.p__site_location, geo.row_id)\n                    )\n                    WHERE geo.otype = 'GeospatialCoordLocation'\n                    GROUP BY geo.pid\n                )\n                SELECT\n                    pid,\n                    CASE\n                        WHEN is_sample_location = 1 AND is_site_location = 1 THEN 'both'\n                        WHEN is_sample_location = 1 THEN 'sample_location_only'\n                        WHEN is_site_location = 1 THEN 'site_location_only'\n                    END as location_type\n                FROM geo_classification\n            `;\n\n            const classifications = await db.query(query);\n\n            // Build lookup map: pid -&gt; location_type\n            const typeMap = new Map();\n            for (const row of classifications) {\n                typeMap.set(row.pid, row.location_type);\n            }\n\n            // Color and size styling by location type\n            const styles = {\n                sample_location_only: {\n                    color: Cesium.Color.fromCssColorString('#2E86AB'),\n                    size: 3\n                },  // Blue - field collection points\n                site_location_only: {\n                    color: Cesium.Color.fromCssColorString('#A23B72'),\n                    size: 6\n                },  // Purple - administrative markers\n                both: {\n                    color: Cesium.Color.fromCssColorString('#F18F01'),\n                    size: 5\n                }   // Orange - dual-purpose\n            };\n\n            // Update colors of existing points\n            const points = content.points;\n            for (let i = 0; i &lt; points.length; i++) {\n                const point = points.get(i);\n                const pid = point.id;\n                const locationType = typeMap.get(pid);\n\n                if (locationType && styles[locationType]) {\n                    point.color = styles[locationType].color;\n                    point.pixelSize = styles[locationType].size;\n                }\n            }\n\n            performance.mark('classify-end');\n            performance.measure('classification', 'classify-start', 'classify-end');\n            const classifyTime = performance.getEntriesByName('classification')[0].duration;\n            console.log(`Classification completed in ${classifyTime.toFixed(0)}ms - updated ${points.length} points`);\n            console.log(`  - Blue (sample_location_only): field collection points`);\n            console.log(`  - Purple (site_location_only): administrative markers`);\n            console.log(`  - Orange (both): dual-purpose locations`);\n        } catch (error) {\n            console.error(\"Classification failed:\", error);\n            console.error(\"Error details:\", error.message);\n\n            // Show user-friendly message in browser console\n            console.warn(\"⚠️ Color-coding failed due to a data loading issue.\");\n            console.warn(\"💡 Tip: This is an intermittent DuckDB-WASM issue with remote files.\");\n            console.warn(\"    Try clicking the button again, or use a local cached file for better reliability.\");\n            console.warn(\"    See the 'Using a local cached file' section above for instructions.\");\n\n            // Note: We don't show an alert() to avoid disrupting the user experience\n            // The page remains functional, just without the color-coding\n        }\n    }\n}\nThe click point ID is “”.\ngeoLoading ? md`(loading…)` : md`\\`\\`\\`\n${JSON.stringify(selectedGeoRecord, null, 2)}\n\\`\\`\\`\n`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Wide)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium_wide.html#getgeorecord-selected",
    "href": "tutorials/parquet_cesium_wide.html#getgeorecord-selected",
    "title": "Using Cesium for display of remote parquet (Wide Format).",
    "section": "1 getGeoRecord (selected)",
    "text": "1 getGeoRecord (selected)\n\n\nCode\npid = clickedPointId\ntestrecord = selectedGeoRecord;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmd`\\`\\`\\`\n${JSON.stringify(testrecord, null, 2)}\n\\`\\`\\`\n`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Wide)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium_wide.html#samples-at-location-via-sampling-event-eric-kansas-query---wide-format",
    "href": "tutorials/parquet_cesium_wide.html#samples-at-location-via-sampling-event-eric-kansas-query---wide-format",
    "title": "Using Cesium for display of remote parquet (Wide Format).",
    "section": "2 Samples at Location via Sampling Event (Eric Kansa’s Query - Wide Format)",
    "text": "2 Samples at Location via Sampling Event (Eric Kansa’s Query - Wide Format)\n\nLoading samples…\n\nThis query implements Eric Kansa’s authoritative get_samples_at_geo_cord_location_via_sample_event function from open-context-py, translated to wide format.\n\n\n\n\n\n\nNoteWide Format Query Advantage\n\n\n\nNarrow format requires 7+ JOINs through edge rows:\nJOIN nodes AS rel_se ON (rel_se.p = 'sample_location' AND list_contains(rel_se.o, geo.row_id))\nJOIN nodes AS se ON (rel_se.s = se.row_id ...)\nWide format uses direct column access (3 JOINs):\nJOIN nodes AS se ON (se.otype = 'SamplingEvent' AND list_contains(se.p__sample_location, geo.row_id))\nThis is typically 2-4x faster over HTTP.\n\n\n**Query Strategy (p__sample_location + p__sampling_site): - Starts at a GeospatialCoordLocation (clicked point) - Walks backward** via p__sample_location column to find SamplingEvents that reference this location - From those events, finds MaterialSampleRecords via p__produced_by column - Requires site context (INNER JOIN on p__sampling_site → SamplingSite)\nReturns: - Geographic coordinates: latitude, longitude - Sample metadata: sample_pid, sample_label, sample_description, sample_alternate_identifiers - Site context: sample_site_label, sample_site_pid - Media: sample_thumbnail_url, has_thumbnail\nOrdering: Prioritizes samples with images (ORDER BY has_thumbnail DESC)\nImportant: This query only returns samples whose sampling events directly reference this geolocation via p__sample_location (EVENT_SAMPLE_LOCATION). Samples that reach this location only through their site’s p__site_location (SITE_LOCATION) are not included. This means site marker locations may return 0 results if no events were recorded at that exact coordinate.\n\nsamples_combined = selectedSamplesCombined\n\n\n\n\n\n\n\nhtml`${\n  combinedLoading ?\n    html`&lt;div class=\"loading\"&gt;Loading samples…&lt;/div&gt;`\n  :\n  samples_combined && samples_combined.length &gt; 0 ?\n    html`&lt;div style=\"max-height: 600px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;\"&gt;\n      &lt;table style=\"width: 100%; border-collapse: collapse; font-size: 0.9em;\"&gt;\n        &lt;thead style=\"position: sticky; top: 0; background: #f8f9fa; z-index: 1;\"&gt;\n          &lt;tr style=\"border-bottom: 2px solid #dee2e6;\"&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Thumbnail&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Sample&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Description&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Site&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Location&lt;/th&gt;\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          ${samples_combined.map((sample, i) =&gt; html`\n            &lt;tr style=\"border-bottom: 1px solid #eee; ${i % 2 === 0 ? 'background: #f8f9fa;' : ''}\"&gt;\n              &lt;td style=\"padding: 8px; width: 100px;\"&gt;\n                ${sample.has_thumbnail ?\n                  html`&lt;a href=\"${sample.sample_thumbnail_url}\" target=\"_blank\"&gt;\n                    &lt;img src=\"${sample.sample_thumbnail_url}\"\n                         alt=\"${sample.sample_label}\"\n                         style=\"max-width: 80px; max-height: 80px; border-radius: 4px; border: 1px solid #ddd;\"&gt;\n                  &lt;/a&gt;`\n                :\n                  html`&lt;div style=\"width: 80px; height: 80px; background: #e9ecef; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;\"&gt;No image&lt;/div&gt;`\n                }\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 4px;\"&gt;\n                  &lt;strong&gt;${sample.sample_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.85em; color: #666;\"&gt;\n                  &lt;a href=\"${sample.sample_pid.startsWith('http') ? sample.sample_pid : sample.sample_alternate_identifiers?.[0] || '#'}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    ${sample.sample_pid.replace('ark:/28722/', 'ark:…/')}\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; max-width: 300px;\"&gt;\n                &lt;div style=\"font-size: 0.85em; color: #495057; line-height: 1.4;\"&gt;\n                  ${sample.sample_description || 'No description'}\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 2px;\"&gt;\n                  &lt;strong&gt;${sample.sample_site_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.75em;\"&gt;\n                  &lt;a href=\"${sample.sample_site_pid}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    View site\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; font-size: 0.85em; color: #666;\"&gt;\n                ${sample.latitude.toFixed(5)}°N&lt;br&gt;\n                ${sample.longitude.toFixed(5)}°E\n              &lt;/td&gt;\n            &lt;/tr&gt;\n          `)}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n    &lt;/div&gt;\n    &lt;div style=\"margin-top: 8px; font-size: 0.9em; color: #666;\"&gt;\n      Found ${samples_combined.length} sample${samples_combined.length !== 1 ? 's' : ''}\n    &lt;/div&gt;`\n  :\n    html`&lt;div style=\"padding: 20px; background: #f8f9fa; border-radius: 4px; color: #6c757d;\"&gt;\n      No samples found at this location via direct location (p__sample_location).\n    &lt;/div&gt;`\n}`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Wide)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium_wide.html#understanding-location-traversals-using-typed-edges-wide-format",
    "href": "tutorials/parquet_cesium_wide.html#understanding-location-traversals-using-typed-edges-wide-format",
    "title": "Using Cesium for display of remote parquet (Wide Format).",
    "section": "3 Understanding Location Traversals Using Typed Edges (Wide Format)",
    "text": "3 Understanding Location Traversals Using Typed Edges (Wide Format)\n\n3.1 The 14 iSamples Typed Edge Types\nThe iSamples property graph uses 14 typed edges to express all relationships. In wide format, these are represented as p__* columns on entity rows rather than separate edge rows:\n\n\n\n\n\n\n\n\nEdge Type\nWide Format Column\nFrom → To\n\n\n\n\nMSR_PRODUCED_BY\np__produced_by\nMaterialSampleRecord → SamplingEvent\n\n\nMSR_REGISTRANT\np__registrant\nMaterialSampleRecord → Agent\n\n\nMSR_KEYWORDS\np__keywords\nMaterialSampleRecord → IdentifiedConcept\n\n\nMSR_HAS_CONTEXT_CATEGORY\np__has_context_category\nMaterialSampleRecord → IdentifiedConcept\n\n\nMSR_HAS_MATERIAL_CATEGORY\np__has_material_category\nMaterialSampleRecord → IdentifiedConcept\n\n\nMSR_HAS_SAMPLE_OBJECT_TYPE\np__has_sample_object_type\nMaterialSampleRecord → IdentifiedConcept\n\n\nEVENT_SAMPLING_SITE\np__sampling_site\nSamplingEvent → SamplingSite\n\n\nEVENT_SAMPLE_LOCATION\np__sample_location\nSamplingEvent → GeospatialCoordLocation\n\n\nEVENT_RESPONSIBILITY\np__responsibility\nSamplingEvent → Agent\n\n\nSITE_LOCATION\np__site_location\nSamplingSite → GeospatialCoordLocation\n\n\n\n\n\n3.2 Two Ways to Get Geographic Coordinates (Wide Format)\n**Direct Location (via p__sample_location / EVENT_SAMPLE_LOCATION)**\nMaterialSampleRecord\n  → p__produced_by →\nSamplingEvent\n  → p__sample_location →\nGeospatialCoordLocation\n**Site-Mediated Location (via p__sampling_site + p__site_location)**\nMaterialSampleRecord\n  → p__produced_by →\nSamplingEvent\n  → p__sampling_site →\nSamplingSite\n  → p__site_location →\nGeospatialCoordLocation\nKey Differences: - Direct uses p__sample_location: 2 edges from Sample to Location - Site-Mediated uses p__sampling_site + p__site_location: 3 edges from Sample to Location - Direct = “Where was this specific sample collected?” - Site-Mediated = “What named site is this sample from, and where is that site?”\nWide Format Advantage: Instead of JOINing through separate edge rows (otype=‘edge’), we directly access the p__* columns on entity rows using list_contains().\nImportant: The queries below use INNER JOIN for both traversals, meaning samples must have connections through both to appear in results. Samples with only one traversal will be excluded.\n\n\n3.3 Full Relationship Map Using Typed Edges (Wide Format)\n                                    Agent\n                                      ↑\n                                      | p__responsibility, p__registrant\n                                      |\nMaterialSampleRecord ─p__produced_by─→ SamplingEvent ─p__sample_location─→ GeospatialCoordLocation\n    |                                       |                                         ↑\n    |                                       |                                         |\n    | p__keywords,                          └─p__sampling_site─→ SamplingSite ─p__site_location─┘\n    | p__has_sample_object_type,\n    | p__has_material_category\n    |\n    └──→ IdentifiedConcept\nEdge Categories (Wide Format Columns): - DIRECT LOCATION: p__produced_by → p__sample_location - SITE-MEDIATED LOCATION: p__produced_by → p__sampling_site → p__site_location - AGENT EDGES: p__registrant, p__responsibility - CONCEPT EDGES: p__keywords, p__has_*_category, p__has_sample_object_type\nKey Insight: SamplingEvent is the central hub for most relationships, except concept edges which attach directly to MaterialSampleRecord.\n\n\n3.4 Query Pattern Analysis (Wide Format)\nThe following analysis shows Eric’s query functions in wide format:\n\n3.4.1 1. get_sample_data_via_sample_pid - Uses BOTH Location Traversals\nMaterialSampleRecord (WHERE pid = ?)\n  → p__produced_by → SamplingEvent\n    ├─→ p__sample_location → GeospatialCoordLocation [Direct]\n    └─→ p__sampling_site → SamplingSite [Site-Mediated]\n\nReturns: sample metadata + lat/lon + site label/pid\nRequired: BOTH traversals must exist (INNER JOIN)\n\n\n3.4.2 2. get_sample_data_agents_sample_pid - Uses Agent Edges\nMaterialSampleRecord (WHERE pid = ?)\n  → p__produced_by → SamplingEvent\n    → p__responsibility → Agent\n\nReturns: sample metadata + agent info (who collected/registered)\nIndependent of: Location traversals (no geographic data)\n\n\n3.4.3 3. get_sample_types_and_keywords_via_sample_pid - Uses Concept Edges\nMaterialSampleRecord (WHERE pid = ?)\n  → p__keywords → IdentifiedConcept\n  → p__has_sample_object_type → IdentifiedConcept\n  → p__has_material_category → IdentifiedConcept\n\nReturns: sample metadata + classification keywords/types\nIndependent of: Location traversals and SamplingEvent!\n\n\n3.4.4 4. get_samples_at_geo_cord_location_via_sample_event - Eric’s Canonical Query\nGeospatialCoordLocation (WHERE pid = ?)  ← START HERE (reverse!)\n  ← p__sample_location ← SamplingEvent [Direct, reversed]\n    ├─→ p__sampling_site → SamplingSite [Site context - provenance!]\n    └─← p__produced_by ← MaterialSampleRecord [complete chain]\n\nReturns: all samples at a given location + site info\nDirection: geo → samples (opposite of other queries)\nKey Insight (from Eric Kansa): This canonical query requires BOTH p__sample_location AND p__sampling_site - it’s not just “find samples at this location” but “find samples at this location that have proper site provenance.”\nSummary Table:\n\n\n\n\n\n\n\n\n\n\nFunction\nDirect Location\nSite-Mediated\nDirection\nNotes\n\n\n\n\nget_sample_data_via_sample_pid\n✅ Required\n✅ Required\nForward\nINNER JOIN - no row if either missing\n\n\nget_sample_data_agents_sample_pid\n❌ N/A\n❌ N/A\nN/A\nUses agent edges instead\n\n\nget_sample_types_and_keywords_via_sample_pid\n❌ N/A\n❌ N/A\nN/A\nDirect concept edges\n\n\nget_samples_at_geo_cord_location_via_sample_event\n✅ Required\n✅ Required\nReverse\nGeo → samples with site provenance",
    "crumbs": [
      "Getting Started",
      "Cesium View (Wide)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium_wide.html#related-samples-via-direct-location-p__sample_location",
    "href": "tutorials/parquet_cesium_wide.html#related-samples-via-direct-location-p__sample_location",
    "title": "Using Cesium for display of remote parquet (Wide Format).",
    "section": "4 Related Samples via Direct Location (p__sample_location)",
    "text": "4 Related Samples via Direct Location (p__sample_location)\n\nLoading related samples (direct location)…\n\nDirect Location (via p__sample_location / EVENT_SAMPLE_LOCATION): find MaterialSampleRecord items whose producing SamplingEvent has a direct p__sample_location pointing to the clicked GeospatialCoordLocation (pid).\n\nChain: MaterialSampleRecord → p__produced_by → SamplingEvent → p__sample_location → GeospatialCoordLocation (clicked pid)\nThis matches the “direct_samples” concept in the Python notebook and is labeled as location_path = 'direct_event_location' in the query.\n\n\nsamples_1 = selectedSamples1\n\n\n\n\n\n\n\nhtml`${\n  s1Loading ?\n    html`&lt;div class=\"loading\"&gt;Loading direct location samples…&lt;/div&gt;`\n  :\n  samples_1 && samples_1.length &gt; 0 ?\n    html`&lt;div style=\"max-height: 600px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;\"&gt;\n      &lt;table style=\"width: 100%; border-collapse: collapse; font-size: 0.9em;\"&gt;\n        &lt;thead style=\"position: sticky; top: 0; background: #f8f9fa; z-index: 1;\"&gt;\n          &lt;tr style=\"border-bottom: 2px solid #dee2e6;\"&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Thumbnail&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Sample&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Description&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Site&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Location&lt;/th&gt;\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          ${samples_1.map((sample, i) =&gt; html`\n            &lt;tr style=\"border-bottom: 1px solid #eee; ${i % 2 === 0 ? 'background: #f8f9fa;' : ''}\"&gt;\n              &lt;td style=\"padding: 8px; width: 100px;\"&gt;\n                ${sample.has_thumbnail ?\n                  html`&lt;a href=\"${sample.sample_thumbnail_url}\" target=\"_blank\"&gt;\n                    &lt;img src=\"${sample.sample_thumbnail_url}\"\n                         alt=\"${sample.sample_label}\"\n                         style=\"max-width: 80px; max-height: 80px; border-radius: 4px; border: 1px solid #ddd;\"&gt;\n                  &lt;/a&gt;`\n                :\n                  html`&lt;div style=\"width: 80px; height: 80px; background: #e9ecef; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;\"&gt;No image&lt;/div&gt;`\n                }\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 4px;\"&gt;\n                  &lt;strong&gt;${sample.sample_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.85em; color: #666;\"&gt;\n                  &lt;a href=\"${sample.sample_pid.startsWith('http') ? sample.sample_pid : sample.sample_alternate_identifiers?.[0] || '#'}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    ${sample.sample_pid.replace('ark:/28722/', 'ark:…/')}\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; max-width: 300px;\"&gt;\n                &lt;div style=\"font-size: 0.85em; color: #495057; line-height: 1.4;\"&gt;\n                  ${sample.sample_description || 'No description'}\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 2px;\"&gt;\n                  &lt;strong&gt;${sample.sample_site_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.75em;\"&gt;\n                  &lt;a href=\"${sample.sample_site_pid}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    View site\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; font-size: 0.85em; color: #666;\"&gt;\n                ${sample.latitude.toFixed(5)}°N&lt;br&gt;\n                ${sample.longitude.toFixed(5)}°E\n              &lt;/td&gt;\n            &lt;/tr&gt;\n          `)}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n    &lt;/div&gt;\n    &lt;div style=\"margin-top: 8px; font-size: 0.9em; color: #666;\"&gt;\n      Found ${samples_1.length} sample${samples_1.length !== 1 ? 's' : ''} via direct location (EVENT_SAMPLE_LOCATION)\n    &lt;/div&gt;`\n  :\n    html`&lt;div style=\"padding: 20px; background: #f8f9fa; border-radius: 4px; color: #6c757d;\"&gt;\n      No samples found via direct location (EVENT_SAMPLE_LOCATION).\n    &lt;/div&gt;`\n}`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Wide)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium_wide.html#related-samples-via-site-mediated-location-p__site_location",
    "href": "tutorials/parquet_cesium_wide.html#related-samples-via-site-mediated-location-p__site_location",
    "title": "Using Cesium for display of remote parquet (Wide Format).",
    "section": "5 Related Samples via Site-Mediated Location (p__site_location)",
    "text": "5 Related Samples via Site-Mediated Location (p__site_location)\n\nLoading related samples (site-mediated)…\n\nSite-Mediated Location (SITE_LOCATION): find MaterialSampleRecord items whose producing SamplingEvent references a SamplingSite via p__sampling_site, and that site’s p__site_location points to the clicked GeospatialCoordLocation (pid).\n\nChain: MaterialSampleRecord → p__produced_by → SamplingEvent → p__sampling_site → SamplingSite → p__site_location → GeospatialCoordLocation (clicked pid)\nThis matches the “samples_via_sites” concept in the Python notebook and is labeled as location_path = 'via_site_location' in the query.\n\n\nsamples_2 = selectedSamples2\n\n\n\n\n\n\n\nhtml`${\n  s2Loading ?\n    html`&lt;div class=\"loading\"&gt;Loading site-mediated samples…&lt;/div&gt;`\n  :\n  samples_2 && samples_2.length &gt; 0 ?\n    html`&lt;div style=\"max-height: 600px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;\"&gt;\n      &lt;table style=\"width: 100%; border-collapse: collapse; font-size: 0.9em;\"&gt;\n        &lt;thead style=\"position: sticky; top: 0; background: #f8f9fa; z-index: 1;\"&gt;\n          &lt;tr style=\"border-bottom: 2px solid #dee2e6;\"&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Thumbnail&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Sample&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Description&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Site&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Location&lt;/th&gt;\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          ${samples_2.map((sample, i) =&gt; html`\n            &lt;tr style=\"border-bottom: 1px solid #eee; ${i % 2 === 0 ? 'background: #f8f9fa;' : ''}\"&gt;\n              &lt;td style=\"padding: 8px; width: 100px;\"&gt;\n                ${sample.has_thumbnail ?\n                  html`&lt;a href=\"${sample.sample_thumbnail_url}\" target=\"_blank\"&gt;\n                    &lt;img src=\"${sample.sample_thumbnail_url}\"\n                         alt=\"${sample.sample_label}\"\n                         style=\"max-width: 80px; max-height: 80px; border-radius: 4px; border: 1px solid #ddd;\"&gt;\n                  &lt;/a&gt;`\n                :\n                  html`&lt;div style=\"width: 80px; height: 80px; background: #e9ecef; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;\"&gt;No image&lt;/div&gt;`\n                }\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 4px;\"&gt;\n                  &lt;strong&gt;${sample.sample_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.85em; color: #666;\"&gt;\n                  &lt;a href=\"${sample.sample_pid.startsWith('http') ? sample.sample_pid : sample.sample_alternate_identifiers?.[0] || '#'}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    ${sample.sample_pid.replace('ark:/28722/', 'ark:…/')}\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; max-width: 300px;\"&gt;\n                &lt;div style=\"font-size: 0.85em; color: #495057; line-height: 1.4;\"&gt;\n                  ${sample.sample_description || 'No description'}\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 2px;\"&gt;\n                  &lt;strong&gt;${sample.sample_site_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.75em;\"&gt;\n                  &lt;a href=\"${sample.sample_site_pid}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    View site\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; font-size: 0.85em; color: #666;\"&gt;\n                ${sample.latitude.toFixed(5)}°N&lt;br&gt;\n                ${sample.longitude.toFixed(5)}°E\n              &lt;/td&gt;\n            &lt;/tr&gt;\n          `)}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n    &lt;/div&gt;\n    &lt;div style=\"margin-top: 8px; font-size: 0.9em; color: #666;\"&gt;\n      Found ${samples_2.length} sample${samples_2.length !== 1 ? 's' : ''} via site-mediated location (SITE_LOCATION)\n    &lt;/div&gt;`\n  :\n    html`&lt;div style=\"padding: 20px; background: #f8f9fa; border-radius: 4px; color: #6c757d;\"&gt;\n      No samples found via site-mediated location (SITE_LOCATION).\n    &lt;/div&gt;`\n}`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Wide)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium_wide.html#geographic-location-classification",
    "href": "tutorials/parquet_cesium_wide.html#geographic-location-classification",
    "title": "Using Cesium for display of remote parquet (Wide Format).",
    "section": "6 Geographic Location Classification",
    "text": "6 Geographic Location Classification\n\n\n\n\n\n\nTip✅ IMPLEMENTED - Differentiated Geographic Visualization\n\n\n\nCurrent implementation: GeospatialCoordLocations are now color-coded by their semantic role in the property graph:\n\n🔵 Blue (small) - sample_location_only: Precise field collection points (EVENT_SAMPLE_LOCATION)\n🟣 Purple (large) - site_location_only: Administrative site markers (SITE_LOCATION)\n🟠 Orange (medium) - both: Dual-purpose locations (used for both direct and site-mediated location)\n\nDiscovery: Analysis of the OpenContext parquet data reveals that geos fall into three distinct categories based on their usage:\n\nsample_location_only: Precise field collection points (EVENT_SAMPLE_LOCATION)\n\nMost common category\nRepresents exact GPS coordinates where sampling events occurred\nVaries per event, even within the same site\n\nsite_location_only: Administrative site markers (SITE_LOCATION)\n\nRepresents general/reference locations for named archaeological sites\nOne coordinate per site\nMay not correspond to any actual collection point\n\nboth: 10,346 geos (5.2%) - Dual-purpose locations\n\nUsed as BOTH p__sample_location AND p__site_location\nPrimarily single-location sites (85% of all sites)\nOccasionally one of many locations at multi-location sites (e.g., PKAP)\n\n\nSite spatial patterns: - 85.4% of sites are compact (single location) - all events at one coordinate - Example: Suberde - 384 events at one location - 14.6% of sites are distributed (multiple locations) - events spread across space - Example: PKAP Survey Area - 15,446 events across 544 different coordinates - Poggio Civitate - 29,985 events across 11,112 coordinates\n\n6.1 Benefits of Current Implementation\n\nEducational: Makes EVENT_SAMPLE_LOCATION vs SITE_LOCATION distinction visually concrete\n\nUsers can SEE the semantic difference between precise and administrative locations\nBlue points show where samples were actually collected (EVENT_SAMPLE_LOCATION)\nPurple points show administrative site markers (SITE_LOCATION)\nDemonstrates the complementary nature of the two geographic paths\n\nExploratory: Enables visual understanding of spatial patterns\n\nArchaeological sites appear as purple markers (large points)\nField collection points appear as blue markers (small points)\nDual-purpose locations appear as orange markers (medium points)\nNo UI filters required - the colors provide immediate visual differentiation\n\nAnalytical: Reveals site spatial structure at a glance\n\nCompact sites: tight cluster of blue points around purple marker\nSurvey areas: purple marker with cloud of blue points spread across region\nIdentifies sampling strategies and field methodologies by visual inspection\n\n\n\n\n6.2 Wide Format Advantage\nThe classification query is simpler in wide format because it directly checks p__sample_location and p__site_location columns instead of querying through edge rows.\nNarrow format (edge rows):\nJOIN nodes e ON (geo.row_id = e.o[1])\nWHERE e.p IN ('sample_location', 'site_location')\nWide format (direct columns):\nLEFT JOIN nodes AS se ON (list_contains(se.p__sample_location, geo.row_id))\nLEFT JOIN nodes AS site ON (list_contains(site.p__site_location, geo.row_id))\n\n\n6.3 Implementation Status\nStatus: ✅ IMPLEMENTED (Basic color-coding by location type)\nWhat’s implemented: - ✅ Classification query using p__sample_location and p__site_location columns - ✅ Conditional styling by location_type - ✅ Color-coded points: Blue (sample_location), Purple (site_location), Orange (both) - ✅ Size differentiation: 3px (field points), 6px (sites), 5px (dual-purpose)\nFuture enhancements (not yet implemented): - ⬜ UI filter controls (checkbox toggles for each location type) - ⬜ Site Explorer Mode (click site → highlight all sample_locations) - ⬜ Convex hull/region drawing for distributed sites - ⬜ Dynamic statistics display on site selection\nThis implementation transforms the visualization from uniform points into a pedagogical tool that visually demonstrates the EVENT_SAMPLE_LOCATION vs SITE_LOCATION distinction in the iSamples metadata model architecture.",
    "crumbs": [
      "Getting Started",
      "Cesium View (Wide)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium_wide.html#see-also",
    "href": "tutorials/parquet_cesium_wide.html#see-also",
    "title": "Using Cesium for display of remote parquet (Wide Format).",
    "section": "7 See Also",
    "text": "7 See Also\n\nCesium View (Narrow Format) - Same visualization using the narrow schema\nNarrow vs Wide Performance - Benchmark comparison\niSamples Parquet Tutorial - Introduction to parquet format",
    "crumbs": [
      "Getting Started",
      "Cesium View (Wide)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium.html",
    "href": "tutorials/parquet_cesium.html",
    "title": "Using Cesium for display of remote parquet.",
    "section": "",
    "text": "This page renders points from an iSamples parquet file on cesium using point primitives.\nCesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwNzk3NjkyMy1iNGI1LTRkN2UtODRiMy04OTYwYWE0N2M3ZTkiLCJpZCI6Njk1MTcsImlhdCI6MTYzMzU0MTQ3N30.e70dpNzOCDRLDGxRguQCC-tRzGzA-23Xgno5lNgCeB4';\nviewof parquet_path = Inputs.text({\n  label:\"Source\",\n  value:\"https://storage.googleapis.com/opencontext-parquet/oc_isamples_pqg.parquet\",\n  placeholder: \"URL or file:///path/to/file.parquet\",\n  width:\"100%\",\n  submit:true\n});\nviewof searchGeoPid = Inputs.text({\n  label:\"Jump to Geocode\",\n  placeholder: \"Paste geocode PID (e.g., geoloc_04d6e816218b1a8798fa90b3d1d43bf4c043a57f)\",\n  width:\"100%\",\n  submit:true\n});\nviewof classifyTrigger = {\n  let count = 0;\n  const button = html`&lt;button\n    style=\"padding: 8px 16px; margin: 10px 0; background: #2E86AB; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;\"&gt;\n    🎨 Color-code by type (sample/site/both)\n  &lt;/button&gt;`;\n  button.onclick = () =&gt; {\n    count++;\n    button.value = count;\n    button.dispatchEvent(new CustomEvent(\"input\"));\n  };\n  button.value = count;\n  return button;\n}\n\n// Alias for handler compatibility\nclassifyDots = classifyTrigger &gt; 0 ? classifyTrigger : null\nCode\ndb = {\n  const instance = await DuckDBClient.of();\n  await instance.query(`create view nodes as select * from read_parquet('${parquet_path}')`)\n  return instance;\n}\n\n\nasync function loadData(query, params = [], waiting_id = null, key = \"default\") {\n    // latest-only guard per key\n    loadData._latest = loadData._latest || new Map();\n    const requestToken = Symbol();\n    loadData._latest.set(key, requestToken);\n\n    // Get loading indicator\n    const waiter = waiting_id ? document.getElementById(waiting_id) : null;\n    if (waiter) waiter.hidden = false;\n\n    try {\n        // Run the (slow) query\n        const _results = await db.query(query, params);\n        // Ignore stale responses\n        if (loadData._latest.get(key) !== requestToken) return null;\n        return _results;\n    } catch (error) {\n        if (waiter && loadData._latest.get(key) === requestToken) {\n            waiter.innerHTML = `&lt;pre&gt;${error}&lt;/pre&gt;`;\n        }\n        return null;\n    } finally {\n        // Hide the waiter (if there is one) only if latest\n        if (waiter && loadData._latest.get(key) === requestToken) {\n            waiter.hidden = true;\n        }\n    }\n}\n\nlocations = {\n    // Performance telemetry\n    performance.mark('locations-start');\n\n    // Get loading indicator element for progress updates\n    const loadingDiv = document.getElementById('loading_1');\n    if (loadingDiv) {\n        loadingDiv.hidden = false;\n        loadingDiv.innerHTML = 'Loading geocodes...';\n    }\n\n    // Fast query: just get all distinct geocodes (no classification!)\n    const query = `\n        SELECT DISTINCT\n            pid,\n            latitude,\n            longitude\n        FROM nodes\n        WHERE otype = 'GeospatialCoordLocation'\n    `;\n\n    performance.mark('query-start');\n    const data = await loadData(query, [], \"loading_1\", \"locations\");\n    performance.mark('query-end');\n    performance.measure('locations-query', 'query-start', 'query-end');\n    const queryTime = performance.getEntriesByName('locations-query')[0].duration;\n    console.log(`Query executed in ${queryTime.toFixed(0)}ms - retrieved ${data.length} locations`);\n\n    // Clear the existing PointPrimitiveCollection\n    content.points.removeAll();\n\n    // Single color for all points (blue)\n    const defaultColor = Cesium.Color.fromCssColorString('#2E86AB');\n    const defaultSize = 4;\n\n    // Render points in chunks to keep UI responsive\n    const CHUNK_SIZE = 500;\n    const scalar = new Cesium.NearFarScalar(1.5e2, 2, 8.0e6, 0.2);\n\n    performance.mark('render-start');\n    for (let i = 0; i &lt; data.length; i += CHUNK_SIZE) {\n        const chunk = data.slice(i, i + CHUNK_SIZE);\n        const endIdx = Math.min(i + CHUNK_SIZE, data.length);\n\n        // Update progress indicator\n        if (loadingDiv) {\n            const pct = Math.round((endIdx / data.length) * 100);\n            loadingDiv.innerHTML = `Rendering geocodes... ${endIdx.toLocaleString()}/${data.length.toLocaleString()} (${pct}%)`;\n        }\n\n        // Add points for this chunk\n        for (const row of chunk) {\n            content.points.add({\n                id: row.pid,\n                position: Cesium.Cartesian3.fromDegrees(\n                    row.longitude,  //longitude\n                    row.latitude,   //latitude\n                    0               //elevation, m\n                ),\n                pixelSize: defaultSize,\n                color: defaultColor,\n                scaleByDistance: scalar,\n            });\n        }\n\n        // Yield to browser between chunks to keep UI responsive\n        if (i + CHUNK_SIZE &lt; data.length) {\n            await new Promise(resolve =&gt; setTimeout(resolve, 0));\n        }\n    }\n    performance.mark('render-end');\n    performance.measure('locations-render', 'render-start', 'render-end');\n    const renderTime = performance.getEntriesByName('locations-render')[0].duration;\n\n    // Hide loading indicator\n    if (loadingDiv) {\n        loadingDiv.hidden = true;\n    }\n\n    performance.mark('locations-end');\n    performance.measure('locations-total', 'locations-start', 'locations-end');\n    const totalTime = performance.getEntriesByName('locations-total')[0].duration;\n\n    console.log(`Rendering completed in ${renderTime.toFixed(0)}ms`);\n    console.log(`Total time (query + render): ${totalTime.toFixed(0)}ms`);\n\n    content.enableTracking();\n    return data;\n}\n\n\nfunction createShowPrimitive(viewer) {\n    return function(movement) {\n        // Get the point at the mouse end position\n        const selectPoint = viewer.viewer.scene.pick(movement.endPosition);        \n\n        // Clear the current selection, if there is one and it is different to the selectPoint\n        if (viewer.currentSelection !== null) {\n            //console.log(`selected.p ${viewer.currentSelection}`)\n            if (Cesium.defined(selectPoint) && selectPoint !== viewer.currentSelection) {\n                console.log(`selected.p 2 ${viewer.currentSelection}`)\n                viewer.currentSelection.primitive.pixelSize = 4;\n                viewer.currentSelection.primitive.outlineColor = Cesium.Color.TRANSPARENT;\n                viewer.currentSelection.outlineWidth = 0;\n                viewer.currentSelection = null;\n            }\n        }\n\n        // If selectPoint is valid and no currently selected point\n        if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n            //console.log(`showPrimitiveId ${selectPoint.id}`);\n            //const carto = Cesium.Cartographic.fromCartesian(selectPoint.primitive.position)\n            viewer.pointLabel.position = selectPoint.primitive.position;\n            viewer.pointLabel.label.show = true;\n            //viewer.pointLabel.label.text = `id:${selectPoint.id}, ${carto}`;\n            viewer.pointLabel.label.text = `${selectPoint.id}`;\n            selectPoint.primitive.pixelSize = 20;\n            selectPoint.primitive.outlineColor = Cesium.Color.YELLOW;\n            selectPoint.primitive.outlineWidth = 3;\n            viewer.currentSelection = selectPoint;\n        } else {\n            viewer.pointLabel.label.show = false;\n        }            \n    }\n}\n\nclass CView {\n    constructor(target) {\n        this.viewer = new Cesium.Viewer(\n            target, {\n                timeline: false,\n                animation: false,\n                baseLayerPicker: false,\n                fullscreenElement: target,\n                terrain: Cesium.Terrain.fromWorldTerrain()\n            });\n        this.currentSelection = null;\n        this.point_size = 1;\n        this.n_points = 0;\n        // https://cesium.com/learn/cesiumjs/ref-doc/PointPrimitiveCollection.html\n        this.points = new Cesium.PointPrimitiveCollection();\n        this.viewer.scene.primitives.add(this.points);\n     \n        this.pointLabel = this.viewer.entities.add({\n            label: {\n            show: false,\n            showBackground: true,\n            font: \"14px monospace\",\n            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,\n            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,\n            pixelOffset: new Cesium.Cartesian2(15, 0),\n            // this attribute will prevent this entity clipped by the terrain\n            disableDepthTestDistance: Number.POSITIVE_INFINITY,\n            text:\"\",\n            },\n        });\n\n        this.pickHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        // Can also do this rather than wait for the points to be generated\n        //this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n\n        this.selectHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n        this.selectHandler.setInputAction((e) =&gt; {\n            const selectPoint = this.viewer.scene.pick(e.position);\n            if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty(\"primitive\")) {\n                mutable clickedPointId = selectPoint.id;\n            }\n        },Cesium.ScreenSpaceEventType.LEFT_CLICK);\n\n    }\n\n    enableTracking() {\n        this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n    }\n}\n\ncontent = new CView(\"cesiumContainer\");\n\nasync function getGeoRecord(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return \"unset\";\n    }\n    const q = `SELECT row_id, pid, otype, latitude, longitude FROM nodes WHERE otype='GeospatialCoordLocation' AND pid=?`;\n    const rows = await loadData(q, [pid], \"loading_geo\", \"geo\");\n    return rows && rows.length ? rows[0] : null;\n}\n\nasync function get_samples_1(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return [];\n    }\n    // Direct Location (EVENT_SAMPLE_LOCATION) - enhanced to match Eric's query structure\n    const q = `\n        SELECT\n            geo.latitude,\n            geo.longitude,\n            site.label AS sample_site_label,\n            site.pid AS sample_site_pid,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail,\n            'direct_event_location' as location_path\n        FROM nodes AS geo\n        JOIN nodes AS rel_se ON (\n            rel_se.p = 'sample_location'\n            AND\n            list_contains(rel_se.o, geo.row_id)\n        )\n        JOIN nodes AS se ON (\n            rel_se.s = se.row_id\n            AND\n            se.otype = 'SamplingEvent'\n        )\n        JOIN nodes AS rel_site ON (\n            se.row_id = rel_site.s\n            AND\n            rel_site.p = 'sampling_site'\n        )\n        JOIN nodes AS site ON (\n            rel_site.o[1] = site.row_id\n            AND\n            site.otype = 'SamplingSite'\n        )\n        JOIN nodes AS rel_samp ON (\n            rel_samp.p = 'produced_by'\n            AND\n            list_contains(rel_samp.o, se.row_id)\n        )\n        JOIN nodes AS samp ON (\n            rel_samp.s = samp.row_id\n            AND\n            samp.otype = 'MaterialSampleRecord'\n        )\n        WHERE geo.pid = ?\n          AND geo.otype = 'GeospatialCoordLocation'\n        ORDER BY has_thumbnail DESC\n    `;\n    performance.mark('samples1-start');\n    const result = await loadData(q, [pid], \"loading_s1\", \"samples_1\");\n    performance.mark('samples1-end');\n    performance.measure('samples1-query', 'samples1-start', 'samples1-end');\n    const queryTime = performance.getEntriesByName('samples1-query')[0].duration;\n    console.log(`Direct location query (EVENT_SAMPLE_LOCATION) executed in ${queryTime.toFixed(0)}ms - retrieved ${result?.length || 0} samples`);\n    return result ?? [];\n}\n\nasync function get_samples_2(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return [];\n    }\n    // Site-Mediated Location (EVENT_SAMPLING_SITE → SITE_LOCATION) - enhanced to match Eric's query structure\n    const q = `\n        SELECT\n            geo.latitude,\n            geo.longitude,\n            site.label AS sample_site_label,\n            site.pid AS sample_site_pid,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail,\n            'via_site_location' as location_path\n        FROM nodes AS geo\n        JOIN nodes AS rel_site_geo ON (\n            rel_site_geo.p = 'site_location'\n            AND\n            list_contains(rel_site_geo.o, geo.row_id)\n        )\n        JOIN nodes AS site ON (\n            rel_site_geo.s = site.row_id\n            AND\n            site.otype = 'SamplingSite'\n        )\n        JOIN nodes AS rel_se_site ON (\n            rel_se_site.p = 'sampling_site'\n            AND\n            list_contains(rel_se_site.o, site.row_id)\n        )\n        JOIN nodes AS se ON (\n            rel_se_site.s = se.row_id\n            AND\n            se.otype = 'SamplingEvent'\n        )\n        JOIN nodes AS rel_samp ON (\n            rel_samp.p = 'produced_by'\n            AND\n            list_contains(rel_samp.o, se.row_id)\n        )\n        JOIN nodes AS samp ON (\n            rel_samp.s = samp.row_id\n            AND\n            samp.otype = 'MaterialSampleRecord'\n        )\n        WHERE geo.pid = ?\n          AND geo.otype = 'GeospatialCoordLocation'\n        ORDER BY has_thumbnail DESC\n    `;\n    performance.mark('samples2-start');\n    const result = await loadData(q, [pid], \"loading_s2\", \"samples_2\");\n    performance.mark('samples2-end');\n    performance.measure('samples2-query', 'samples2-start', 'samples2-end');\n    const queryTime = performance.getEntriesByName('samples2-query')[0].duration;\n    console.log(`Site-mediated location query (SITE_LOCATION) executed in ${queryTime.toFixed(0)}ms - retrieved ${result?.length || 0} samples`);\n    return result ?? [];\n}\n\nasync function get_samples_at_geo_cord_location_via_sample_event(pid) {\n    if (pid === null || pid ===\"\" || pid == \"unset\") {\n        return [];\n    }\n    // Eric Kansa's authoritative query from open-context-py\n    // Source: https://github.com/ekansa/open-context-py/blob/staging/opencontext_py/apps/all_items/isamples/isamples_explore.py\n    const q = `\n        SELECT\n            geo.latitude,\n            geo.longitude,\n            site.label AS sample_site_label,\n            site.pid AS sample_site_pid,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail\n        FROM nodes AS geo\n        JOIN nodes AS rel_se ON (\n            rel_se.p = 'sample_location'\n            AND\n            list_contains(rel_se.o, geo.row_id)\n        )\n        JOIN nodes AS se ON (\n            rel_se.s = se.row_id\n            AND\n            se.otype = 'SamplingEvent'\n        )\n        JOIN nodes AS rel_site ON (\n            se.row_id = rel_site.s\n            AND\n            rel_site.p = 'sampling_site'\n        )\n        JOIN nodes AS site ON (\n            rel_site.o[1] = site.row_id\n            AND\n            site.otype = 'SamplingSite'\n        )\n        JOIN nodes AS rel_samp ON (\n            rel_samp.p = 'produced_by'\n            AND\n            list_contains(rel_samp.o, se.row_id)\n        )\n        JOIN nodes AS samp ON (\n            rel_samp.s = samp.row_id\n            AND\n            samp.otype = 'MaterialSampleRecord'\n        )\n        WHERE geo.pid = ?\n          AND geo.otype = 'GeospatialCoordLocation'\n        ORDER BY has_thumbnail DESC\n    `;\n    performance.mark('eric-query-start');\n    const result = await loadData(q, [pid], \"loading_combined\", \"samples_combined\");\n    performance.mark('eric-query-end');\n    performance.measure('eric-query', 'eric-query-start', 'eric-query-end');\n    const queryTime = performance.getEntriesByName('eric-query')[0].duration;\n    console.log(`Eric's query executed in ${queryTime.toFixed(0)}ms - retrieved ${result?.length || 0} samples`);\n    return result ?? [];\n}\n\nasync function get_sample_data_via_sample_pid(sample_pid) {\n    if (sample_pid === null || sample_pid === \"\" || sample_pid === \"unset\") {\n        return null;\n    }\n    // Eric Kansa's query: Get full sample data including geo and site info\n    const q = `\n        SELECT\n            samp.row_id,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail,\n            geo.latitude,\n            geo.longitude,\n            site.label AS sample_site_label,\n            site.pid AS sample_site_pid\n        FROM nodes AS samp\n        JOIN nodes AS samp_rel_se ON (\n            samp_rel_se.s = samp.row_id\n            AND\n            samp_rel_se.p = 'produced_by'\n        )\n        JOIN nodes AS se ON (\n            samp_rel_se.o[1] = se.row_id\n            AND\n            se.otype = 'SamplingEvent'\n        )\n        JOIN nodes AS geo_rel_se ON (\n            geo_rel_se.s = se.row_id\n            AND\n            geo_rel_se.p = 'sample_location'\n        )\n        JOIN nodes AS geo ON (\n            geo_rel_se.o[1] = geo.row_id\n            AND\n            geo.otype = 'GeospatialCoordLocation'\n        )\n        JOIN nodes AS site_rel_se ON (\n            site_rel_se.s = se.row_id\n            AND\n            site_rel_se.p = 'sampling_site'\n        )\n        JOIN nodes AS site ON (\n            site_rel_se.o[1] = site.row_id\n            AND\n            site.otype = 'SamplingSite'\n        )\n        WHERE samp.pid = ?\n          AND samp.otype = 'MaterialSampleRecord'\n    `;\n    const result = await loadData(q, [sample_pid], \"loading_sample_data\", \"sample_data\");\n    return result && result.length ? result[0] : null;\n}\n\nasync function get_sample_data_agents_sample_pid(sample_pid) {\n    if (sample_pid === null || sample_pid === \"\" || sample_pid === \"unset\") {\n        return [];\n    }\n    // Eric Kansa's query: Get agent info (who collected/registered)\n    const q = `\n        SELECT\n            samp.row_id,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            samp.description AS sample_description,\n            samp.thumbnail_url AS sample_thumbnail_url,\n            samp.thumbnail_url IS NOT NULL as has_thumbnail,\n            agent_rel_se.p AS predicate,\n            agent.pid AS agent_pid,\n            agent.name AS agent_name,\n            agent.alternate_identifiers AS agent_alternate_identifiers\n        FROM nodes AS samp\n        JOIN nodes AS samp_rel_se ON (\n            samp_rel_se.s = samp.row_id\n            AND\n            samp_rel_se.p = 'produced_by'\n        )\n        JOIN nodes AS se ON (\n            samp_rel_se.o[1] = se.row_id\n            AND\n            se.otype = 'SamplingEvent'\n        )\n        JOIN nodes AS agent_rel_se ON (\n            agent_rel_se.s = se.row_id\n            AND\n            list_contains(['responsibility', 'registrant'], agent_rel_se.p)\n        )\n        JOIN nodes AS agent ON (\n            list_contains(agent_rel_se.o, agent.row_id)\n            AND\n            agent.otype = 'Agent'\n        )\n        WHERE samp.pid = ?\n          AND samp.otype = 'MaterialSampleRecord'\n    `;\n    const result = await loadData(q, [sample_pid], \"loading_agents\", \"agents\");\n    return result ?? [];\n}\n\nasync function get_sample_types_and_keywords_via_sample_pid(sample_pid) {\n    if (sample_pid === null || sample_pid === \"\" || sample_pid === \"unset\") {\n        return [];\n    }\n    // Eric Kansa's query: Get classification keywords and types\n    const q = `\n        SELECT\n            samp.row_id,\n            samp.pid AS sample_pid,\n            samp.alternate_identifiers AS sample_alternate_identifiers,\n            samp.label AS sample_label,\n            kw_rel.p AS predicate,\n            kw.pid AS keyword_pid,\n            kw.label AS keyword\n        FROM nodes AS samp\n        JOIN nodes AS kw_rel ON (\n            kw_rel.s = samp.row_id\n            AND\n            list_contains(['keywords', 'has_sample_object_type', 'has_material_category'], kw_rel.p)\n        )\n        JOIN nodes AS kw ON (\n            list_contains(kw_rel.o, kw.row_id)\n            AND\n            kw.otype = 'IdentifiedConcept'\n        )\n        WHERE samp.pid = ?\n          AND samp.otype = 'MaterialSampleRecord'\n    `;\n    const result = await loadData(q, [sample_pid], \"loading_keywords\", \"keywords\");\n    return result ?? [];\n}\n\nasync function locationUsedBy(rowid){\n    if (rowid === undefined || rowid === null) {\n        return [];\n    }\n    const q = `select pid, otype from nodes where row_id in (select nodes.s from nodes where list_contains(nodes.o, ?));`;\n    return db.query(q, [rowid]);\n}\n\nmutable clickedPointId = \"unset\";\n// Loading flags to control UI clearing while fetching\nmutable geoLoading = false;\nmutable s1Loading = false;\nmutable s2Loading = false;\nmutable combinedLoading = false;\n\n// Precompute selection-driven data with loading flags\nselectedGeoRecord = {\n    mutable geoLoading = true;\n    try {\n        return await getGeoRecord(clickedPointId);\n    } finally {\n        mutable geoLoading = false;\n    }\n}\n\nselectedSamples1 = {\n    mutable s1Loading = true;\n    try {\n        return await get_samples_1(clickedPointId);\n    } finally {\n        mutable s1Loading = false;\n    }\n}\n\nselectedSamples2 = {\n    mutable s2Loading = true;\n    try {\n        return await get_samples_2(clickedPointId);\n    } finally {\n        mutable s2Loading = false;\n    }\n}\n\nselectedSamplesCombined = {\n    mutable combinedLoading = true;\n    try {\n        return await get_samples_at_geo_cord_location_via_sample_event(clickedPointId);\n    } finally {\n        mutable combinedLoading = false;\n    }\n}\n\nmd`Retrieved ${pointdata.length} locations from ${parquet_path}.`;\n// Center initial Cesium view on PKAP Survey Area and also set Home to PKAP!\n{\n    const viewer = content.viewer;\n    // PKAP Survey Area near Cyprus\n    // Source: https://opencontext.org/subjects/48fd434c-f6d3...\n    const pkapLat = 34.987406;\n    const pkapLon = 33.708047;\n    const delta = 0.3; // degrees padding around point\n    const pkapRect = Cesium.Rectangle.fromDegrees(\n        pkapLon - delta, // west (lon)\n        pkapLat - delta, // south (lat)\n        pkapLon + delta, // east (lon)\n        pkapLat + delta  // north (lat)\n    );\n\n    // Make the Home button go to PKAP as well\n    Cesium.Camera.DEFAULT_VIEW_RECTANGLE = pkapRect;\n    Cesium.Camera.DEFAULT_VIEW_FACTOR = 0.5;\n\n    // Apply camera after the first render to avoid resize/tab visibility issues\n    const once = () =&gt; {\n        viewer.camera.setView({ destination: pkapRect });\n        viewer.scene.postRender.removeEventListener(once);\n    };\n    viewer.scene.postRender.addEventListener(once);\n}\n// Handle geocode search: fly to location and trigger queries\n{\n    if (searchGeoPid && searchGeoPid.trim() !== \"\") {\n        const pid = searchGeoPid.trim();\n\n        // Look up the geocode in the database\n        const q = `SELECT pid, latitude, longitude FROM nodes WHERE otype='GeospatialCoordLocation' AND pid=?`;\n        const result = await db.query(q, [pid]);\n\n        if (result && result.length &gt; 0) {\n            const geo = result[0];\n            const viewer = content.viewer;\n\n            // Fly camera to the location\n            const position = Cesium.Cartesian3.fromDegrees(\n                geo.longitude,\n                geo.latitude,\n                15000  // 15km altitude for good view\n            );\n\n            viewer.camera.flyTo({\n                destination: position,\n                duration: 2.0,  // 2 second flight\n                complete: () =&gt; {\n                    // After camera arrives, trigger the click to load data\n                    mutable clickedPointId = pid;\n                }\n            });\n        } else {\n            // Geocode not found - could display error to user\n            console.warn(`Geocode not found: ${pid}`);\n        }\n    }\n}\n// Handle optional classification button: recolor dots by type\n{\n    if (classifyDots !== null) {\n        console.log(\"Classifying dots by type...\");\n        performance.mark('classify-start');\n\n        try {\n            // Run the classification query\n            const query = `\n                WITH geo_classification AS (\n                    SELECT\n                        geo.pid,\n                        MAX(CASE WHEN e.p = 'sample_location' THEN 1 ELSE 0 END) as is_sample_location,\n                        MAX(CASE WHEN e.p = 'site_location' THEN 1 ELSE 0 END) as is_site_location\n                    FROM nodes geo\n                    JOIN nodes e ON (geo.row_id = e.o[1])\n                    WHERE geo.otype = 'GeospatialCoordLocation'\n                    GROUP BY geo.pid\n                )\n                SELECT\n                    pid,\n                    CASE\n                        WHEN is_sample_location = 1 AND is_site_location = 1 THEN 'both'\n                        WHEN is_sample_location = 1 THEN 'sample_location_only'\n                        WHEN is_site_location = 1 THEN 'site_location_only'\n                    END as location_type\n                FROM geo_classification\n            `;\n\n            const classifications = await db.query(query);\n\n            // Build lookup map: pid -&gt; location_type\n            const typeMap = new Map();\n            for (const row of classifications) {\n                typeMap.set(row.pid, row.location_type);\n            }\n\n            // Color and size styling by location type\n            const styles = {\n                sample_location_only: {\n                    color: Cesium.Color.fromCssColorString('#2E86AB'),\n                    size: 3\n                },  // Blue - field collection points\n                site_location_only: {\n                    color: Cesium.Color.fromCssColorString('#A23B72'),\n                    size: 6\n                },  // Purple - administrative markers\n                both: {\n                    color: Cesium.Color.fromCssColorString('#F18F01'),\n                    size: 5\n                }   // Orange - dual-purpose\n            };\n\n            // Update colors of existing points\n            const points = content.points;\n            for (let i = 0; i &lt; points.length; i++) {\n                const point = points.get(i);\n                const pid = point.id;\n                const locationType = typeMap.get(pid);\n\n                if (locationType && styles[locationType]) {\n                    point.color = styles[locationType].color;\n                    point.pixelSize = styles[locationType].size;\n                }\n            }\n\n            performance.mark('classify-end');\n            performance.measure('classification', 'classify-start', 'classify-end');\n            const classifyTime = performance.getEntriesByName('classification')[0].duration;\n            console.log(`Classification completed in ${classifyTime.toFixed(0)}ms - updated ${points.length} points`);\n            console.log(`  - Blue (sample_location_only): field collection points`);\n            console.log(`  - Purple (site_location_only): administrative markers`);\n            console.log(`  - Orange (both): dual-purpose locations`);\n        } catch (error) {\n            console.error(\"Classification failed:\", error);\n            console.error(\"Error details:\", error.message);\n\n            // Show user-friendly message in browser console\n            console.warn(\"⚠️ Color-coding failed due to a data loading issue.\");\n            console.warn(\"💡 Tip: This is an intermittent DuckDB-WASM issue with remote files.\");\n            console.warn(\"    Try clicking the button again, or use a local cached file for better reliability.\");\n            console.warn(\"    See the 'Using a local cached file' section above for instructions.\");\n\n            // Note: We don't show an alert() to avoid disrupting the user experience\n            // The page remains functional, just without the color-coding\n        }\n    }\n}\nThe click point ID is “”.\ngeoLoading ? md`(loading…)` : md`\\`\\`\\`\n${JSON.stringify(selectedGeoRecord, null, 2)}\n\\`\\`\\`\n`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Narrow)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium.html#getgeorecord-selected",
    "href": "tutorials/parquet_cesium.html#getgeorecord-selected",
    "title": "Using Cesium for display of remote parquet.",
    "section": "1 getGeoRecord (selected)",
    "text": "1 getGeoRecord (selected)\n\n\nCode\npid = clickedPointId\ntestrecord = selectedGeoRecord;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmd`\\`\\`\\`\n${JSON.stringify(testrecord, null, 2)}\n\\`\\`\\`\n`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Narrow)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium.html#samples-at-location-via-sampling-event-eric-kansas-query",
    "href": "tutorials/parquet_cesium.html#samples-at-location-via-sampling-event-eric-kansas-query",
    "title": "Using Cesium for display of remote parquet.",
    "section": "2 Samples at Location via Sampling Event (Eric Kansa’s Query)",
    "text": "2 Samples at Location via Sampling Event (Eric Kansa’s Query)\n\nLoading samples…\n\nThis query implements Eric Kansa’s authoritative get_samples_at_geo_cord_location_via_sample_event function from open-context-py.\nQuery Strategy (EVENT_SAMPLE_LOCATION + EVENT_SAMPLING_SITE): - Starts at a GeospatialCoordLocation (clicked point) - Walks backward via EVENT_SAMPLE_LOCATION edges to find SamplingEvents that reference this location - From those events, finds MaterialSampleRecords produced by them via MSR_PRODUCED_BY - Requires site context (INNER JOIN on EVENT_SAMPLING_SITE → SamplingSite) - this is the provenance constraint\nReturns: - Geographic coordinates: latitude, longitude - Sample metadata: sample_pid, sample_label, sample_description, sample_alternate_identifiers - Site context: sample_site_label, sample_site_pid - Media: sample_thumbnail_url, has_thumbnail\nOrdering: Prioritizes samples with images (ORDER BY has_thumbnail DESC)\nImportant: This query only returns samples whose sampling events directly reference this geolocation via EVENT_SAMPLE_LOCATION (direct location). Samples that reach this location only through their site’s SITE_LOCATION (site-mediated) are not included. This means site marker locations may return 0 results if no events were recorded at that exact coordinate.\n\nsamples_combined = selectedSamplesCombined\n\n\n\n\n\n\n\nhtml`${\n  combinedLoading ?\n    html`&lt;div class=\"loading\"&gt;Loading samples…&lt;/div&gt;`\n  :\n  samples_combined && samples_combined.length &gt; 0 ?\n    html`&lt;div style=\"max-height: 600px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;\"&gt;\n      &lt;table style=\"width: 100%; border-collapse: collapse; font-size: 0.9em;\"&gt;\n        &lt;thead style=\"position: sticky; top: 0; background: #f8f9fa; z-index: 1;\"&gt;\n          &lt;tr style=\"border-bottom: 2px solid #dee2e6;\"&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Thumbnail&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Sample&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Description&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Site&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Location&lt;/th&gt;\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          ${samples_combined.map((sample, i) =&gt; html`\n            &lt;tr style=\"border-bottom: 1px solid #eee; ${i % 2 === 0 ? 'background: #f8f9fa;' : ''}\"&gt;\n              &lt;td style=\"padding: 8px; width: 100px;\"&gt;\n                ${sample.has_thumbnail ?\n                  html`&lt;a href=\"${sample.sample_thumbnail_url}\" target=\"_blank\"&gt;\n                    &lt;img src=\"${sample.sample_thumbnail_url}\"\n                         alt=\"${sample.sample_label}\"\n                         style=\"max-width: 80px; max-height: 80px; border-radius: 4px; border: 1px solid #ddd;\"&gt;\n                  &lt;/a&gt;`\n                :\n                  html`&lt;div style=\"width: 80px; height: 80px; background: #e9ecef; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;\"&gt;No image&lt;/div&gt;`\n                }\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 4px;\"&gt;\n                  &lt;strong&gt;${sample.sample_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.85em; color: #666;\"&gt;\n                  &lt;a href=\"${sample.sample_pid.startsWith('http') ? sample.sample_pid : sample.sample_alternate_identifiers?.[0] || '#'}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    ${sample.sample_pid.replace('ark:/28722/', 'ark:…/')}\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; max-width: 300px;\"&gt;\n                &lt;div style=\"font-size: 0.85em; color: #495057; line-height: 1.4;\"&gt;\n                  ${sample.sample_description || 'No description'}\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 2px;\"&gt;\n                  &lt;strong&gt;${sample.sample_site_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.75em;\"&gt;\n                  &lt;a href=\"${sample.sample_site_pid}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    View site\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; font-size: 0.85em; color: #666;\"&gt;\n                ${sample.latitude.toFixed(5)}°N&lt;br&gt;\n                ${sample.longitude.toFixed(5)}°E\n              &lt;/td&gt;\n            &lt;/tr&gt;\n          `)}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n    &lt;/div&gt;\n    &lt;div style=\"margin-top: 8px; font-size: 0.9em; color: #666;\"&gt;\n      Found ${samples_combined.length} sample${samples_combined.length !== 1 ? 's' : ''}\n    &lt;/div&gt;`\n  :\n    html`&lt;div style=\"padding: 20px; background: #f8f9fa; border-radius: 4px; color: #6c757d;\"&gt;\n      No samples found at this location via direct location (EVENT_SAMPLE_LOCATION).\n    &lt;/div&gt;`\n}`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Narrow)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium.html#understanding-location-traversals-using-typed-edges",
    "href": "tutorials/parquet_cesium.html#understanding-location-traversals-using-typed-edges",
    "title": "Using Cesium for display of remote parquet.",
    "section": "3 Understanding Location Traversals Using Typed Edges",
    "text": "3 Understanding Location Traversals Using Typed Edges\n\n3.1 The 14 iSamples Typed Edge Types\nThe iSamples property graph uses 14 typed edges to express all relationships. These provide a precise, unambiguous vocabulary for describing any query traversal:\n\n\n\n\n\n\n\nEdge Type\nFrom → To\n\n\n\n\nMSR_PRODUCED_BY\nMaterialSampleRecord → SamplingEvent\n\n\nMSR_REGISTRANT\nMaterialSampleRecord → Agent\n\n\nMSR_KEYWORDS\nMaterialSampleRecord → IdentifiedConcept\n\n\nMSR_HAS_CONTEXT_CATEGORY\nMaterialSampleRecord → IdentifiedConcept\n\n\nMSR_HAS_MATERIAL_CATEGORY\nMaterialSampleRecord → IdentifiedConcept\n\n\nMSR_HAS_SAMPLE_OBJECT_TYPE\nMaterialSampleRecord → IdentifiedConcept\n\n\nMSR_CURATION\nMaterialSampleRecord → MaterialSampleCuration\n\n\nMSR_RELATED_RESOURCE\nMaterialSampleRecord → SampleRelation\n\n\nEVENT_SAMPLING_SITE\nSamplingEvent → SamplingSite\n\n\nEVENT_SAMPLE_LOCATION\nSamplingEvent → GeospatialCoordLocation\n\n\nEVENT_RESPONSIBILITY\nSamplingEvent → Agent\n\n\nEVENT_HAS_CONTEXT_CATEGORY\nSamplingEvent → IdentifiedConcept\n\n\nSITE_LOCATION\nSamplingSite → GeospatialCoordLocation\n\n\nCURATION_RESPONSIBILITY\nMaterialSampleCuration → Agent\n\n\n\n\n\n3.2 Two Ways to Get Geographic Coordinates\nThere are two traversal patterns from a MaterialSampleRecord to geographic coordinates:\nDirect Location (via EVENT_SAMPLE_LOCATION)\nMaterialSampleRecord\n  → MSR_PRODUCED_BY →\nSamplingEvent\n  → EVENT_SAMPLE_LOCATION →\nGeospatialCoordLocation\nSite-Mediated Location (via EVENT_SAMPLING_SITE → SITE_LOCATION)\nMaterialSampleRecord\n  → MSR_PRODUCED_BY →\nSamplingEvent\n  → EVENT_SAMPLING_SITE →\nSamplingSite\n  → SITE_LOCATION →\nGeospatialCoordLocation\nKey Differences: - Direct uses EVENT_SAMPLE_LOCATION: 2 edges from Sample to Location - Site-Mediated uses EVENT_SAMPLING_SITE + SITE_LOCATION: 3 edges from Sample to Location - Direct = “Where was this specific sample collected?” - Site-Mediated = “What named site is this sample from, and where is that site?”\nImportant: The queries below use INNER JOIN for both traversals, meaning samples must have connections through both to appear in results. Samples with only one traversal will be excluded.\n\n\n3.3 Full Relationship Map Using Typed Edges\nThe iSamples property graph contains many more relationships than just the geographic traversals:\n                                    Agent\n                                      ↑\n                                      | EVENT_RESPONSIBILITY, MSR_REGISTRANT\n                                      |\nMaterialSampleRecord ─MSR_PRODUCED_BY─→ SamplingEvent ─EVENT_SAMPLE_LOCATION─→ GeospatialCoordLocation\n    |                                       |                                         ↑\n    |                                       |                                         |\n    | MSR_KEYWORDS,                         └─EVENT_SAMPLING_SITE─→ SamplingSite ─SITE_LOCATION─┘\n    | MSR_HAS_SAMPLE_OBJECT_TYPE,\n    | MSR_HAS_MATERIAL_CATEGORY\n    |\n    └──→ IdentifiedConcept\nEdge Categories: - DIRECT LOCATION: MSR_PRODUCED_BY → EVENT_SAMPLE_LOCATION - SITE-MEDIATED LOCATION: MSR_PRODUCED_BY → EVENT_SAMPLING_SITE → SITE_LOCATION - AGENT EDGES: MSR_REGISTRANT, EVENT_RESPONSIBILITY - CONCEPT EDGES: MSR_KEYWORDS, MSR_HAS_*_CATEGORY, MSR_HAS_SAMPLE_OBJECT_TYPE\nKey Insight: SamplingEvent is the central hub for most relationships, except concept edges which attach directly to MaterialSampleRecord.\n\n\n3.4 Query Pattern Analysis (from Eric Kansa’s open-context-py)\nThe following analysis is based on Eric’s query functions that demonstrate different edge traversal patterns:\n\n3.4.1 1. get_sample_data_via_sample_pid - Uses BOTH Location Traversals\nMaterialSampleRecord (WHERE pid = ?)\n  → MSR_PRODUCED_BY → SamplingEvent\n    ├─→ EVENT_SAMPLE_LOCATION → GeospatialCoordLocation [Direct]\n    └─→ EVENT_SAMPLING_SITE → SamplingSite [Site-Mediated]\n\nReturns: sample metadata + lat/lon + site label/pid\nRequired: BOTH traversals must exist (INNER JOIN)\n\n\n3.4.2 2. get_sample_data_agents_sample_pid - Uses Agent Edges\nMaterialSampleRecord (WHERE pid = ?)\n  → MSR_PRODUCED_BY → SamplingEvent\n    → EVENT_RESPONSIBILITY → Agent\n\nReturns: sample metadata + agent info (who collected/registered)\nIndependent of: Location traversals (no geographic data)\n\n\n3.4.3 3. get_sample_types_and_keywords_via_sample_pid - Uses Concept Edges\nMaterialSampleRecord (WHERE pid = ?)\n  → MSR_KEYWORDS → IdentifiedConcept\n  → MSR_HAS_SAMPLE_OBJECT_TYPE → IdentifiedConcept\n  → MSR_HAS_MATERIAL_CATEGORY → IdentifiedConcept\n\nReturns: sample metadata + classification keywords/types\nIndependent of: Location traversals and SamplingEvent!\n\n\n3.4.4 4. get_samples_at_geo_cord_location_via_sample_event - Eric’s Canonical Query\nGeospatialCoordLocation (WHERE pid = ?)  ← START HERE (reverse!)\n  ← EVENT_SAMPLE_LOCATION ← SamplingEvent [Direct, reversed]\n    ├─→ EVENT_SAMPLING_SITE → SamplingSite [Site context - provenance!]\n    └─← MSR_PRODUCED_BY ← MaterialSampleRecord [complete chain]\n\nReturns: all samples at a given location + site info\nDirection: geo → samples (opposite of other queries)\nKey Insight (from Eric Kansa): This canonical query requires BOTH EVENT_SAMPLE_LOCATION AND EVENT_SAMPLING_SITE - it’s not just “find samples at this location” but “find samples at this location that have proper site provenance.”\nSummary Table:\n\n\n\n\n\n\n\n\n\n\nFunction\nDirect Location\nSite-Mediated\nDirection\nNotes\n\n\n\n\nget_sample_data_via_sample_pid\n✅ Required\n✅ Required\nForward\nINNER JOIN - no row if either missing\n\n\nget_sample_data_agents_sample_pid\n❌ N/A\n❌ N/A\nN/A\nUses agent edges instead\n\n\nget_sample_types_and_keywords_via_sample_pid\n❌ N/A\n❌ N/A\nN/A\nDirect concept edges\n\n\nget_samples_at_geo_cord_location_via_sample_event\n✅ Required\n✅ Required\nReverse\nGeo → samples with site provenance",
    "crumbs": [
      "Getting Started",
      "Cesium View (Narrow)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium.html#related-samples-via-direct-location-event_sample_location",
    "href": "tutorials/parquet_cesium.html#related-samples-via-direct-location-event_sample_location",
    "title": "Using Cesium for display of remote parquet.",
    "section": "4 Related Samples via Direct Location (EVENT_SAMPLE_LOCATION)",
    "text": "4 Related Samples via Direct Location (EVENT_SAMPLE_LOCATION)\n\nLoading related samples (direct location)…\n\nDirect Location (via EVENT_SAMPLE_LOCATION): find MaterialSampleRecord items whose producing SamplingEvent has a direct sample_location edge pointing to the clicked GeospatialCoordLocation (pid).\n\nChain: MaterialSampleRecord → produced_by → SamplingEvent → sample_location → GeospatialCoordLocation (clicked pid)\nThis matches the “direct_samples” concept in the Python notebook and is labeled as location_path = 'direct_event_location' in the query.\n\n\nsamples_1 = selectedSamples1\n\n\n\n\n\n\n\nhtml`${\n  s1Loading ?\n    html`&lt;div class=\"loading\"&gt;Loading direct location samples…&lt;/div&gt;`\n  :\n  samples_1 && samples_1.length &gt; 0 ?\n    html`&lt;div style=\"max-height: 600px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;\"&gt;\n      &lt;table style=\"width: 100%; border-collapse: collapse; font-size: 0.9em;\"&gt;\n        &lt;thead style=\"position: sticky; top: 0; background: #f8f9fa; z-index: 1;\"&gt;\n          &lt;tr style=\"border-bottom: 2px solid #dee2e6;\"&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Thumbnail&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Sample&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Description&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Site&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Location&lt;/th&gt;\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          ${samples_1.map((sample, i) =&gt; html`\n            &lt;tr style=\"border-bottom: 1px solid #eee; ${i % 2 === 0 ? 'background: #f8f9fa;' : ''}\"&gt;\n              &lt;td style=\"padding: 8px; width: 100px;\"&gt;\n                ${sample.has_thumbnail ?\n                  html`&lt;a href=\"${sample.sample_thumbnail_url}\" target=\"_blank\"&gt;\n                    &lt;img src=\"${sample.sample_thumbnail_url}\"\n                         alt=\"${sample.sample_label}\"\n                         style=\"max-width: 80px; max-height: 80px; border-radius: 4px; border: 1px solid #ddd;\"&gt;\n                  &lt;/a&gt;`\n                :\n                  html`&lt;div style=\"width: 80px; height: 80px; background: #e9ecef; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;\"&gt;No image&lt;/div&gt;`\n                }\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 4px;\"&gt;\n                  &lt;strong&gt;${sample.sample_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.85em; color: #666;\"&gt;\n                  &lt;a href=\"${sample.sample_pid.startsWith('http') ? sample.sample_pid : sample.sample_alternate_identifiers?.[0] || '#'}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    ${sample.sample_pid.replace('ark:/28722/', 'ark:…/')}\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; max-width: 300px;\"&gt;\n                &lt;div style=\"font-size: 0.85em; color: #495057; line-height: 1.4;\"&gt;\n                  ${sample.sample_description || 'No description'}\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 2px;\"&gt;\n                  &lt;strong&gt;${sample.sample_site_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.75em;\"&gt;\n                  &lt;a href=\"${sample.sample_site_pid}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    View site\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; font-size: 0.85em; color: #666;\"&gt;\n                ${sample.latitude.toFixed(5)}°N&lt;br&gt;\n                ${sample.longitude.toFixed(5)}°E\n              &lt;/td&gt;\n            &lt;/tr&gt;\n          `)}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n    &lt;/div&gt;\n    &lt;div style=\"margin-top: 8px; font-size: 0.9em; color: #666;\"&gt;\n      Found ${samples_1.length} sample${samples_1.length !== 1 ? 's' : ''} via direct location (EVENT_SAMPLE_LOCATION)\n    &lt;/div&gt;`\n  :\n    html`&lt;div style=\"padding: 20px; background: #f8f9fa; border-radius: 4px; color: #6c757d;\"&gt;\n      No samples found via direct location (EVENT_SAMPLE_LOCATION).\n    &lt;/div&gt;`\n}`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Narrow)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium.html#related-samples-via-site-mediated-location-event_sampling_site-site_location",
    "href": "tutorials/parquet_cesium.html#related-samples-via-site-mediated-location-event_sampling_site-site_location",
    "title": "Using Cesium for display of remote parquet.",
    "section": "5 Related Samples via Site-Mediated Location (EVENT_SAMPLING_SITE → SITE_LOCATION)",
    "text": "5 Related Samples via Site-Mediated Location (EVENT_SAMPLING_SITE → SITE_LOCATION)\n\nLoading related samples (site-mediated)…\n\nSite-Mediated Location (via EVENT_SAMPLING_SITE → SITE_LOCATION): find MaterialSampleRecord items whose producing SamplingEvent references a SamplingSite via sampling_site edge, and that site’s site_location edge points to the clicked GeospatialCoordLocation (pid).\n\nChain: MaterialSampleRecord → MSR_PRODUCED_BY → SamplingEvent → EVENT_SAMPLING_SITE → SamplingSite → SITE_LOCATION → GeospatialCoordLocation (clicked pid)\nThis matches the “samples_via_sites” concept in the Python notebook and is labeled as location_path = 'via_site_location' in the query.\n\n\nsamples_2 = selectedSamples2\n\n\n\n\n\n\n\nhtml`${\n  s2Loading ?\n    html`&lt;div class=\"loading\"&gt;Loading site-mediated samples…&lt;/div&gt;`\n  :\n  samples_2 && samples_2.length &gt; 0 ?\n    html`&lt;div style=\"max-height: 600px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;\"&gt;\n      &lt;table style=\"width: 100%; border-collapse: collapse; font-size: 0.9em;\"&gt;\n        &lt;thead style=\"position: sticky; top: 0; background: #f8f9fa; z-index: 1;\"&gt;\n          &lt;tr style=\"border-bottom: 2px solid #dee2e6;\"&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Thumbnail&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Sample&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Description&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Site&lt;/th&gt;\n            &lt;th style=\"padding: 12px; text-align: left;\"&gt;Location&lt;/th&gt;\n          &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          ${samples_2.map((sample, i) =&gt; html`\n            &lt;tr style=\"border-bottom: 1px solid #eee; ${i % 2 === 0 ? 'background: #f8f9fa;' : ''}\"&gt;\n              &lt;td style=\"padding: 8px; width: 100px;\"&gt;\n                ${sample.has_thumbnail ?\n                  html`&lt;a href=\"${sample.sample_thumbnail_url}\" target=\"_blank\"&gt;\n                    &lt;img src=\"${sample.sample_thumbnail_url}\"\n                         alt=\"${sample.sample_label}\"\n                         style=\"max-width: 80px; max-height: 80px; border-radius: 4px; border: 1px solid #ddd;\"&gt;\n                  &lt;/a&gt;`\n                :\n                  html`&lt;div style=\"width: 80px; height: 80px; background: #e9ecef; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 0.8em;\"&gt;No image&lt;/div&gt;`\n                }\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 4px;\"&gt;\n                  &lt;strong&gt;${sample.sample_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.85em; color: #666;\"&gt;\n                  &lt;a href=\"${sample.sample_pid.startsWith('http') ? sample.sample_pid : sample.sample_alternate_identifiers?.[0] || '#'}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    ${sample.sample_pid.replace('ark:/28722/', 'ark:…/')}\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; max-width: 300px;\"&gt;\n                &lt;div style=\"font-size: 0.85em; color: #495057; line-height: 1.4;\"&gt;\n                  ${sample.sample_description || 'No description'}\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px;\"&gt;\n                &lt;div style=\"margin-bottom: 2px;\"&gt;\n                  &lt;strong&gt;${sample.sample_site_label}&lt;/strong&gt;\n                &lt;/div&gt;\n                &lt;div style=\"font-size: 0.75em;\"&gt;\n                  &lt;a href=\"${sample.sample_site_pid}\"\n                     target=\"_blank\"\n                     style=\"color: #007bff; text-decoration: none;\"&gt;\n                    View site\n                  &lt;/a&gt;\n                &lt;/div&gt;\n              &lt;/td&gt;\n              &lt;td style=\"padding: 8px; font-size: 0.85em; color: #666;\"&gt;\n                ${sample.latitude.toFixed(5)}°N&lt;br&gt;\n                ${sample.longitude.toFixed(5)}°E\n              &lt;/td&gt;\n            &lt;/tr&gt;\n          `)}\n        &lt;/tbody&gt;\n      &lt;/table&gt;\n    &lt;/div&gt;\n    &lt;div style=\"margin-top: 8px; font-size: 0.9em; color: #666;\"&gt;\n      Found ${samples_2.length} sample${samples_2.length !== 1 ? 's' : ''} via site-mediated location (SITE_LOCATION)\n    &lt;/div&gt;`\n  :\n    html`&lt;div style=\"padding: 20px; background: #f8f9fa; border-radius: 4px; color: #6c757d;\"&gt;\n      No samples found via site-mediated location (SITE_LOCATION).\n    &lt;/div&gt;`\n}`",
    "crumbs": [
      "Getting Started",
      "Cesium View (Narrow)"
    ]
  },
  {
    "objectID": "tutorials/parquet_cesium.html#geographic-location-classification",
    "href": "tutorials/parquet_cesium.html#geographic-location-classification",
    "title": "Using Cesium for display of remote parquet.",
    "section": "6 Geographic Location Classification",
    "text": "6 Geographic Location Classification\n\n\n\n\n\n\nTip✅ IMPLEMENTED - Differentiated Geographic Visualization\n\n\n\nCurrent implementation: GeospatialCoordLocations are now color-coded by their semantic role in the property graph:\n\n🔵 Blue (small) - sample_location_only: Precise field collection points (via EVENT_SAMPLE_LOCATION)\n🟣 Purple (large) - site_location_only: Administrative site markers (via SITE_LOCATION)\n🟠 Orange (medium) - both: Dual-purpose locations (used by both edge types)\n\nDiscovery: Analysis of the OpenContext parquet data reveals that geos fall into three distinct categories based on their usage:\n\nsample_location_only: Precise field collection points (via EVENT_SAMPLE_LOCATION)\n\nMost common category\nRepresents exact GPS coordinates where sampling events occurred\nVaries per event, even within the same site\n\nsite_location_only: Administrative site markers (via SITE_LOCATION)\n\nRepresents general/reference locations for named archaeological sites\nOne coordinate per site\nMay not correspond to any actual collection point\n\nboth: 10,346 geos (5.2%) - Dual-purpose locations\n\nUsed by BOTH EVENT_SAMPLE_LOCATION AND SITE_LOCATION edges\nPrimarily single-location sites (85% of all sites)\nOccasionally one of many locations at multi-location sites (e.g., PKAP)\n\n\nSite spatial patterns: - 85.4% of sites are compact (single location) - all events at one coordinate - Example: Suberde - 384 events at one location - 14.6% of sites are distributed (multiple locations) - events spread across space - Example: PKAP Survey Area - 15,446 events across 544 different coordinates - Poggio Civitate - 29,985 events across 11,112 coordinates\n\n6.1 Benefits of Current Implementation\n\nEducational: Makes direct vs site-mediated location distinction visually concrete\n\nUsers can SEE the semantic difference between precise and administrative locations\nBlue points show where samples were actually collected (EVENT_SAMPLE_LOCATION)\nPurple points show administrative site markers (SITE_LOCATION)\nDemonstrates the complementary nature of the two location edge types\n\nExploratory: Enables visual understanding of spatial patterns\n\nArchaeological sites appear as purple markers (large points)\nField collection points appear as blue markers (small points)\nDual-purpose locations appear as orange markers (medium points)\nNo UI filters required - the colors provide immediate visual differentiation\n\nAnalytical: Reveals site spatial structure at a glance\n\nCompact sites: tight cluster of blue points around purple marker\nSurvey areas: purple marker with cloud of blue points spread across region\nIdentifies sampling strategies and field methodologies by visual inspection\n\n\n\n\n6.2 Advanced Features (Future)\nSite Explorer Mode: - Click a site_location (purple marker) → reveal all its sample_locations (blue points) - Draw convex hull or region around the site’s collection points - Display site statistics: event count, spatial extent, temporal range\nExample interaction:\nUser clicks PKAP Survey Area marker (purple)\n→ Highlights 544 blue sample_location points within the survey area\n→ Shows: \"15,446 events across 544 locations (0.7% at site marker, 99.3% elsewhere)\"\n→ Draws polygon boundary around the survey extent\n\n\n6.3 Implementation Status\nStatus: ✅ IMPLEMENTED (Basic color-coding by location type)\nWhat’s implemented: - ✅ Classification query with CTE (lines 123-146) - ✅ Conditional styling by location_type (lines 153-166) - ✅ Color-coded points: Blue (sample_location), Purple (site_location), Orange (both) - ✅ Size differentiation: 3px (field points), 6px (sites), 5px (dual-purpose)\nPerformance impact: - Query execution time increased slightly due to JOIN and GROUP BY - Same 198k points rendered, now with semantic color coding - No noticeable performance degradation in browser rendering\nFuture enhancements (not yet implemented): - ⬜ UI filter controls (checkbox toggles for each location type) - ⬜ Site Explorer Mode (click site → highlight all sample_locations) - ⬜ Convex hull/region drawing for distributed sites - ⬜ Dynamic statistics display on site selection\nThis implementation transforms the visualization from uniform points into a pedagogical tool that visually demonstrates the EVENT_SAMPLE_LOCATION vs SITE_LOCATION distinction in the iSamples typed edge model.",
    "crumbs": [
      "Getting Started",
      "Cesium View (Narrow)"
    ]
  },
  {
    "objectID": "people.html",
    "href": "people.html",
    "title": "Some of those who contributed to iSamples",
    "section": "",
    "text": "Cao, Sean\nChoe, Saebyl\nCui, Hong\nDavies, Neil (PI)\nDeck, John\nKansa, Eric C\nKansa, Sarah Whitcher\n\n\n\nKunze, John\nLehnert, Kerstin (PI)\nMandel, Danny\nMeyer, Christopher\nRamdeen, Sarah\nRaia, Natalie\nRichard, Steve\n\n\n\nRobinson, Erin\nSnyder, Rebecca\nSong, Lu-lin\nThomer, Andrea (PI)\nVieglais, Dave (PI)\nWalls, Ramona L\nYee, Raymond",
    "crumbs": [
      "People"
    ]
  },
  {
    "objectID": "design/actors.html",
    "href": "design/actors.html",
    "title": "Actors in the iSamples environment",
    "section": "",
    "text": "Curator\nConsumer\nContributor\nPortal Manager\nAdministrator"
  }
]