---
title: Using Cesium for geospatial visualization of remote parquet data
categories: [parquet, spatial, recipe]
---

One key development of the iSamples project centers on the demonstration of low-cost, simplified, and more sustainable approaches to access, analyze and visualize scientific data. Rather than relying upon elaborate and costly server-side infrastructure, iSamples demonstrates how open source technologies like parquet and DuckDB-WASM can streamline cheaper and faster approaches to interacting with geospatial data.

This page demonstrates how geospatial data can be dynamically accessed from a remote parquet file in cloud storage. The page uses Cesium for browser visualization of these spatial data on a 3D global map. The data in this demonstration comes from [Open Context's](https://opencontext.org/) export of specimen (archaeological artifact and ecofact) records for iSamples. However, this demonstration can also work with any other iSamples compliant parquet data source made publicly accessible on the Web.


<script src="https://cesium.com/downloads/cesiumjs/releases/1.133/Build/Cesium/Cesium.js"></script>
<link href="https://cesium.com/downloads/cesiumjs/releases/1.133/Build/Cesium/Widgets/widgets.css" rel="stylesheet"></link>
<style>
    div.cesium-topleft {
        display: block;
        position: absolute;
        background: #00000099;
        color: white;
        height: auto;
        z-index: 999;        
    }
    #cesiumContainer {
        aspect-ratio: 1/1;
    }
</style>

```{ojs}
//| output: false
Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwNzk3NjkyMy1iNGI1LTRkN2UtODRiMy04OTYwYWE0N2M3ZTkiLCJpZCI6Njk1MTcsImlhdCI6MTYzMzU0MTQ3N30.e70dpNzOCDRLDGxRguQCC-tRzGzA-23Xgno5lNgCeB4';
```

```{ojs}
//| echo: false
viewof parquet_path = Inputs.text({label:"Source", value:"https://storage.googleapis.com/opencontext-parquet/oc_isamples_pqg.parquet", width:"100%", submit:true});
```

```{ojs}
//| code-fold: true

// Create a DuckDB instance
db = {
  const instance = await DuckDBClient.of();
  await instance.query(`create view nodes as select * from read_parquet('${parquet_path}')`)
  return instance;
}


async function loadData(query, params=[], waiting_id=null) {
    // Get loading indicator
    const waiter = document.getElementById(waiting_id);
    if (waiter) {
        waiter.hidden = false;
    }
    try {
        // Run the (slow) query
        const _results = await db.query(query, ...params);
        return _results;
    } catch (error) {
        if (waiter) {
            waiter.innerHtml = `<pre>${error}</pre>`;
        }
        return null;
    } finally {
        // Hide the waiter (if there is one)
        if (waiter) {
            waiter.hidden = true;
        }
    }
}

locations = {
    // get the content form the parquet file
    const query = `SELECT pid, latitude, longitude FROM nodes WHERE otype='GeospatialCoordLocation'`;
    const data = await loadData(query, [], "loading_1");

    // Clear the existing PointPrimitiveCollection
    content.points.removeAll();
    //content.points = new Cesium.PointPrimitiveCollection();

    // create point primitives for cesium display
    const scalar = new Cesium.NearFarScalar(1.5e2, 2, 8.0e6, 0.2);
    const color = Cesium.Color.PINK;
    const point_size = 4;
    for (const row of data) {
        content.points.add({
            id: row.pid,
            // https://cesium.com/learn/cesiumjs/ref-doc/Cartesian3.html#.fromDegrees
            position: Cesium.Cartesian3.fromDegrees(
                row.longitude,  //longitude
                row.latitude,   //latitude
                0,//randomCoordinateJitter(10.0, 10.0), //elevation, m
            ),
            pixelSize: point_size,
            color: color,
            scaleByDistance: scalar,
        });
    }
    content.enableTracking();
    return data;
}


function createShowPrimitive(viewer) {
    return function(movement) {
        // Get the point at the mouse end position
        const selectPoint = viewer.viewer.scene.pick(movement.endPosition);        

        // Clear the current selection, if there is one and it is different to the selectPoint
        if (viewer.currentSelection !== null) {
            //console.log(`selected.p ${viewer.currentSelection}`)
            if (Cesium.defined(selectPoint) && selectPoint !== viewer.currentSelection) {
                console.log(`selected.p 2 ${viewer.currentSelection}`)
                viewer.currentSelection.primitive.pixelSize = 4;
                viewer.currentSelection.primitive.outlineColor = Cesium.Color.TRANSPARENT;
                viewer.currentSelection.outlineWidth = 0;
                viewer.currentSelection = null;
            }
        }

        // If selectPoint is valid and no currently selected point
        if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty("primitive")) {
            //console.log(`showPrimitiveId ${selectPoint.id}`);
            //const carto = Cesium.Cartographic.fromCartesian(selectPoint.primitive.position)
            viewer.pointLabel.position = selectPoint.primitive.position;
            viewer.pointLabel.label.show = true;
            //viewer.pointLabel.label.text = `id:${selectPoint.id}, ${carto}`;
            viewer.pointLabel.label.text = `${selectPoint.id}`;
            selectPoint.primitive.pixelSize = 20;
            selectPoint.primitive.outlineColor = Cesium.Color.YELLOW;
            selectPoint.primitive.outlineWidth = 3;
            viewer.currentSelection = selectPoint;
        } else {
            viewer.pointLabel.label.show = false;
        }            
    }
}

class CView {
    constructor(target) {
        this.viewer = new Cesium.Viewer(
            target, {
                timeline: false,
                animation: false,
                baseLayerPicker: false,
                fullscreenElement: target,
                terrain: Cesium.Terrain.fromWorldTerrain()
            });
        this.currentSelection = null;
        this.point_size = 1;
        this.n_points = 0;
        // https://cesium.com/learn/cesiumjs/ref-doc/PointPrimitiveCollection.html
        this.points = new Cesium.PointPrimitiveCollection();
        this.viewer.scene.primitives.add(this.points);
     
        this.pointLabel = this.viewer.entities.add({
            label: {
            show: false,
            showBackground: true,
            font: "14px monospace",
            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
            pixelOffset: new Cesium.Cartesian2(15, 0),
            // this attribute will prevent this entity clipped by the terrain
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            text:"",
            },
        });

        this.pickHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
        // Can also do this rather than wait for the points to be generated
        //this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);

        this.selectHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
        this.selectHandler.setInputAction((e) => {
            const selectPoint = this.viewer.scene.pick(e.position);
            if (Cesium.defined(selectPoint) && selectPoint.hasOwnProperty("primitive")) {
                mutable clickedPointId = selectPoint.id;
            }
        },Cesium.ScreenSpaceEventType.LEFT_CLICK);

    }

    enableTracking() {
        this.pickHandler.setInputAction(createShowPrimitive(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
}

content = new CView("cesiumContainer");

async function getGeoRecord(pid) {
    if (pid === null || pid ==="" || pid == "unset") {
        return "unset";
    }
    const q = `SELECT row_id, pid, otype, latitude, longitude FROM nodes WHERE otype='GeospatialCoordLocation' AND pid=?`;
    const result = await db.queryRow(q, [pid]);
    return result;
}

async function locationUsedBy(rowid){
    if (rowid === undefined || rowid === null) {
        return [];
    }
    const q = `select pid, otype from nodes where row_id in (select nodes.s from nodes where list_contains(nodes.o, ?));`;
    return db.query(q, [rowid]);
}

mutable clickedPointId = "unset";
selectedGeoRecord = await getGeoRecord(clickedPointId);

md`Retrieved ${pointdata.length} locations from ${parquet_path}.`;
```

::: {.panel-tabset}

## Map

<div id="cesiumContainer"></div>

## Data

<div id="loading_1">Loading...</div>

```{ojs}
//| code-fold: true

viewof pointdata = {
    const data_table = Inputs.table(locations, {
        header: {
            row_id:"Row ID",
            pid: "PID",
            latitude: "Latitude",
            longitude: "Longitude"
        },
    });
    return data_table;
}    
```

:::

The number of locations in the file is: ${pointdata.length}.

The click point ID is "${clickedPointId}".

```{ojs}
//| echo: false
md`\`\`\`
${JSON.stringify(selectedGeoRecord, null, 2)}
\`\`\`
`
```

## Table Structure Analysis

Understanding the structure and schema of the parquet file:

### Column Schema

```{ojs}
//| code-fold: true
tableSchema = {
    const query = `DESCRIBE nodes`;
    const data = await loadData(query, [], "loading_schema");
    return data;
}
```

<div id="loading_schema">Loading table schema...</div>

```{ojs}
//| code-fold: true
viewof schemaTable = {
    const data_table = Inputs.table(tableSchema, {
        header: {
            column_name: "Column Name",
            column_type: "Data Type",
            null: "Nullable",
            key: "Key",
            default: "Default",
            extra: "Extra"
        }
    });
    return data_table;
}
```

### Sample Data

First 10 rows of the dataset to understand the data structure:

```{ojs}
//| code-fold: true
sampleData = {
    const query = `SELECT * FROM nodes LIMIT 10`;
    const data = await loadData(query, [], "loading_sample");
    return data;
}
```

<div id="loading_sample">Loading sample data...</div>

```{ojs}
//| code-fold: true
viewof sampleTable = {
    const data_table = Inputs.table(sampleData, {
        layout: "auto",
        width: {
            pid: 200,
            otype: 150
        }
    });
    return data_table;
}
```

### Sample Data by Object Type

Examples of records for each object type to understand the data semantics:

```{ojs}
//| code-fold: true
sampleDataByOtype = {
    // First get the list of unique object types
    const otypeQuery = `SELECT DISTINCT otype FROM nodes ORDER BY otype`;
    const otypes = await loadData(otypeQuery, [], "loading_otype_samples");
    
    const results = [];
    for (const otypeRow of otypes) {
        const otype = otypeRow.otype;
        // Get 3 sample records for each otype
        const sampleQuery = `SELECT * FROM nodes WHERE otype = ? LIMIT 3`;
        const samples = await db.query(sampleQuery, [otype]);
        
        results.push({
            otype: otype,
            count: samples.length,
            samples: samples
        });
    }
    return results;
}
```

<div id="loading_otype_samples">Loading sample data by object type...</div>

```{ojs}
//| code-fold: true
viewof otypeSamplesDisplay = {
    const container = html`<div></div>`;
    
    for (const otypeData of sampleDataByOtype) {
        const section = html`<div style="margin-bottom: 2rem;">
            <h4 style="color: #2563eb; margin-bottom: 0.5rem;">Object Type: ${otypeData.otype}</h4>
            <p style="margin: 0.5rem 0; font-style: italic;">Sample records (showing up to 3):</p>
        </div>`;
        
        // Create a table for this otype's samples
        const table = Inputs.table(otypeData.samples, {
            layout: "auto",
            width: {
                pid: 150,
                otype: 120,
                latitude: 100,
                longitude: 100
            }
        });
        
        section.appendChild(table);
        container.appendChild(section);
    }
    
    return container;
}
```

## Object Type Counts

The distribution of object types (`otype`) in the dataset:

```{ojs}
//| code-fold: true
otypeCounts = {
    const query = `SELECT otype, COUNT(*) as count FROM nodes GROUP BY otype ORDER BY count DESC`;
    const data = await loadData(query, [], "loading_otype");
    return data;
}
```

<div id="loading_otype">Loading object type counts...</div>

```{ojs}
//| code-fold: true
viewof otypeTable = {
    const data_table = Inputs.table(otypeCounts, {
        header: {
            otype: "Object Type",
            count: "Count"
        },
        format: {
            count: d => d.toLocaleString()
        }
    });
    return data_table;
}
```

Total records by object type: ${otypeCounts.reduce((sum, row) => sum + row.count, 0).toLocaleString()}

## Property Distribution Analysis

Understanding the range of properties (predicates) in this graph database structure:

```{ojs}
//| code-fold: true
propertyDistribution = {
    const query = `SELECT p as property, COUNT(*) as count FROM nodes WHERE p IS NOT NULL GROUP BY p ORDER BY count DESC`;
    const data = await loadData(query, [], "loading_properties");
    return data;
}
```

<div id="loading_properties">Loading property distribution...</div>

```{ojs}
//| code-fold: true
viewof propertyTable = {
    const data_table = Inputs.table(propertyDistribution, {
        header: {
            property: "Property (Predicate)",
            count: "Count"
        },
        format: {
            count: d => d.toLocaleString()
        },
        layout: "auto"
    });
    return data_table;
}
```

Total records with properties: ${propertyDistribution.reduce((sum, row) => sum + row.count, 0).toLocaleString()}

Unique properties in the dataset: ${propertyDistribution.length.toLocaleString()}


